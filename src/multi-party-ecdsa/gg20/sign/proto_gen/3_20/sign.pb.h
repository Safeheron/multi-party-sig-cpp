// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: gg20/sign.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_gg20_2fsign_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_gg20_2fsign_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "crypto-suites/crypto-curve/proto_gen/curve_point.pb.switch.h"
#include "crypto-suites/crypto-zkp/proto_gen/zkp.pb.switch.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_gg20_2fsign_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_gg20_2fsign_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_gg20_2fsign_2eproto;
namespace safeheron {
namespace proto {
namespace multi_party_ecdsa {
namespace gg20 {
namespace sign {
class Round0BCMessage;
struct Round0BCMessageDefaultTypeInternal;
extern Round0BCMessageDefaultTypeInternal _Round0BCMessage_default_instance_;
class Round0P2PMessage;
struct Round0P2PMessageDefaultTypeInternal;
extern Round0P2PMessageDefaultTypeInternal _Round0P2PMessage_default_instance_;
class Round1P2PMessage;
struct Round1P2PMessageDefaultTypeInternal;
extern Round1P2PMessageDefaultTypeInternal _Round1P2PMessage_default_instance_;
class Round2BCMessage;
struct Round2BCMessageDefaultTypeInternal;
extern Round2BCMessageDefaultTypeInternal _Round2BCMessage_default_instance_;
class Round3BCMessage;
struct Round3BCMessageDefaultTypeInternal;
extern Round3BCMessageDefaultTypeInternal _Round3BCMessage_default_instance_;
class Round4BCMessage;
struct Round4BCMessageDefaultTypeInternal;
extern Round4BCMessageDefaultTypeInternal _Round4BCMessage_default_instance_;
class Round4P2PMessage;
struct Round4P2PMessageDefaultTypeInternal;
extern Round4P2PMessageDefaultTypeInternal _Round4P2PMessage_default_instance_;
class Round5BCMessage;
struct Round5BCMessageDefaultTypeInternal;
extern Round5BCMessageDefaultTypeInternal _Round5BCMessage_default_instance_;
class Round6BCMessage;
struct Round6BCMessageDefaultTypeInternal;
extern Round6BCMessageDefaultTypeInternal _Round6BCMessage_default_instance_;
}  // namespace sign
}  // namespace gg20
}  // namespace multi_party_ecdsa
}  // namespace proto
}  // namespace safeheron
PROTOBUF_NAMESPACE_OPEN
template<> ::safeheron::proto::multi_party_ecdsa::gg20::sign::Round0BCMessage* Arena::CreateMaybeMessage<::safeheron::proto::multi_party_ecdsa::gg20::sign::Round0BCMessage>(Arena*);
template<> ::safeheron::proto::multi_party_ecdsa::gg20::sign::Round0P2PMessage* Arena::CreateMaybeMessage<::safeheron::proto::multi_party_ecdsa::gg20::sign::Round0P2PMessage>(Arena*);
template<> ::safeheron::proto::multi_party_ecdsa::gg20::sign::Round1P2PMessage* Arena::CreateMaybeMessage<::safeheron::proto::multi_party_ecdsa::gg20::sign::Round1P2PMessage>(Arena*);
template<> ::safeheron::proto::multi_party_ecdsa::gg20::sign::Round2BCMessage* Arena::CreateMaybeMessage<::safeheron::proto::multi_party_ecdsa::gg20::sign::Round2BCMessage>(Arena*);
template<> ::safeheron::proto::multi_party_ecdsa::gg20::sign::Round3BCMessage* Arena::CreateMaybeMessage<::safeheron::proto::multi_party_ecdsa::gg20::sign::Round3BCMessage>(Arena*);
template<> ::safeheron::proto::multi_party_ecdsa::gg20::sign::Round4BCMessage* Arena::CreateMaybeMessage<::safeheron::proto::multi_party_ecdsa::gg20::sign::Round4BCMessage>(Arena*);
template<> ::safeheron::proto::multi_party_ecdsa::gg20::sign::Round4P2PMessage* Arena::CreateMaybeMessage<::safeheron::proto::multi_party_ecdsa::gg20::sign::Round4P2PMessage>(Arena*);
template<> ::safeheron::proto::multi_party_ecdsa::gg20::sign::Round5BCMessage* Arena::CreateMaybeMessage<::safeheron::proto::multi_party_ecdsa::gg20::sign::Round5BCMessage>(Arena*);
template<> ::safeheron::proto::multi_party_ecdsa::gg20::sign::Round6BCMessage* Arena::CreateMaybeMessage<::safeheron::proto::multi_party_ecdsa::gg20::sign::Round6BCMessage>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace safeheron {
namespace proto {
namespace multi_party_ecdsa {
namespace gg20 {
namespace sign {

// ===================================================================

class Round0BCMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:safeheron.proto.multi_party_ecdsa.gg20.sign.Round0BCMessage) */ {
 public:
  inline Round0BCMessage() : Round0BCMessage(nullptr) {}
  ~Round0BCMessage() override;
  explicit PROTOBUF_CONSTEXPR Round0BCMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Round0BCMessage(const Round0BCMessage& from);
  Round0BCMessage(Round0BCMessage&& from) noexcept
    : Round0BCMessage() {
    *this = ::std::move(from);
  }

  inline Round0BCMessage& operator=(const Round0BCMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline Round0BCMessage& operator=(Round0BCMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Round0BCMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const Round0BCMessage* internal_default_instance() {
    return reinterpret_cast<const Round0BCMessage*>(
               &_Round0BCMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Round0BCMessage& a, Round0BCMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(Round0BCMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Round0BCMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Round0BCMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Round0BCMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Round0BCMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Round0BCMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Round0BCMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safeheron.proto.multi_party_ecdsa.gg20.sign.Round0BCMessage";
  }
  protected:
  explicit Round0BCMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageAFieldNumber = 1,
    kCommitmentFieldNumber = 2,
  };
  // string message_a = 1;
  void clear_message_a();
  const std::string& message_a() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message_a(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message_a();
  PROTOBUF_NODISCARD std::string* release_message_a();
  void set_allocated_message_a(std::string* message_a);
  private:
  const std::string& _internal_message_a() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message_a(const std::string& value);
  std::string* _internal_mutable_message_a();
  public:

  // string commitment = 2;
  void clear_commitment();
  const std::string& commitment() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_commitment(ArgT0&& arg0, ArgT... args);
  std::string* mutable_commitment();
  PROTOBUF_NODISCARD std::string* release_commitment();
  void set_allocated_commitment(std::string* commitment);
  private:
  const std::string& _internal_commitment() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_commitment(const std::string& value);
  std::string* _internal_mutable_commitment();
  public:

  // @@protoc_insertion_point(class_scope:safeheron.proto.multi_party_ecdsa.gg20.sign.Round0BCMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_a_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr commitment_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gg20_2fsign_2eproto;
};
// -------------------------------------------------------------------

class Round0P2PMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:safeheron.proto.multi_party_ecdsa.gg20.sign.Round0P2PMessage) */ {
 public:
  inline Round0P2PMessage() : Round0P2PMessage(nullptr) {}
  ~Round0P2PMessage() override;
  explicit PROTOBUF_CONSTEXPR Round0P2PMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Round0P2PMessage(const Round0P2PMessage& from);
  Round0P2PMessage(Round0P2PMessage&& from) noexcept
    : Round0P2PMessage() {
    *this = ::std::move(from);
  }

  inline Round0P2PMessage& operator=(const Round0P2PMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline Round0P2PMessage& operator=(Round0P2PMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Round0P2PMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const Round0P2PMessage* internal_default_instance() {
    return reinterpret_cast<const Round0P2PMessage*>(
               &_Round0P2PMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Round0P2PMessage& a, Round0P2PMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(Round0P2PMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Round0P2PMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Round0P2PMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Round0P2PMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Round0P2PMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Round0P2PMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Round0P2PMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safeheron.proto.multi_party_ecdsa.gg20.sign.Round0P2PMessage";
  }
  protected:
  explicit Round0P2PMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAliceProofFieldNumber = 3,
  };
  // .safeheron.proto.PailEncRangeProof_V1 alice_proof = 3;
  bool has_alice_proof() const;
  private:
  bool _internal_has_alice_proof() const;
  public:
  void clear_alice_proof();
  const ::safeheron::proto::PailEncRangeProof_V1& alice_proof() const;
  PROTOBUF_NODISCARD ::safeheron::proto::PailEncRangeProof_V1* release_alice_proof();
  ::safeheron::proto::PailEncRangeProof_V1* mutable_alice_proof();
  void set_allocated_alice_proof(::safeheron::proto::PailEncRangeProof_V1* alice_proof);
  private:
  const ::safeheron::proto::PailEncRangeProof_V1& _internal_alice_proof() const;
  ::safeheron::proto::PailEncRangeProof_V1* _internal_mutable_alice_proof();
  public:
  void unsafe_arena_set_allocated_alice_proof(
      ::safeheron::proto::PailEncRangeProof_V1* alice_proof);
  ::safeheron::proto::PailEncRangeProof_V1* unsafe_arena_release_alice_proof();

  // @@protoc_insertion_point(class_scope:safeheron.proto.multi_party_ecdsa.gg20.sign.Round0P2PMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::safeheron::proto::PailEncRangeProof_V1* alice_proof_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gg20_2fsign_2eproto;
};
// -------------------------------------------------------------------

class Round1P2PMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:safeheron.proto.multi_party_ecdsa.gg20.sign.Round1P2PMessage) */ {
 public:
  inline Round1P2PMessage() : Round1P2PMessage(nullptr) {}
  ~Round1P2PMessage() override;
  explicit PROTOBUF_CONSTEXPR Round1P2PMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Round1P2PMessage(const Round1P2PMessage& from);
  Round1P2PMessage(Round1P2PMessage&& from) noexcept
    : Round1P2PMessage() {
    *this = ::std::move(from);
  }

  inline Round1P2PMessage& operator=(const Round1P2PMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline Round1P2PMessage& operator=(Round1P2PMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Round1P2PMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const Round1P2PMessage* internal_default_instance() {
    return reinterpret_cast<const Round1P2PMessage*>(
               &_Round1P2PMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Round1P2PMessage& a, Round1P2PMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(Round1P2PMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Round1P2PMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Round1P2PMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Round1P2PMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Round1P2PMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Round1P2PMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Round1P2PMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safeheron.proto.multi_party_ecdsa.gg20.sign.Round1P2PMessage";
  }
  protected:
  explicit Round1P2PMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageBForKGammaFieldNumber = 1,
    kMessageBForKWFieldNumber = 2,
    kBobProof1FieldNumber = 3,
    kBobProof2FieldNumber = 4,
  };
  // string message_b_for_k_gamma = 1;
  void clear_message_b_for_k_gamma();
  const std::string& message_b_for_k_gamma() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message_b_for_k_gamma(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message_b_for_k_gamma();
  PROTOBUF_NODISCARD std::string* release_message_b_for_k_gamma();
  void set_allocated_message_b_for_k_gamma(std::string* message_b_for_k_gamma);
  private:
  const std::string& _internal_message_b_for_k_gamma() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message_b_for_k_gamma(const std::string& value);
  std::string* _internal_mutable_message_b_for_k_gamma();
  public:

  // string message_b_for_k_w = 2;
  void clear_message_b_for_k_w();
  const std::string& message_b_for_k_w() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message_b_for_k_w(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message_b_for_k_w();
  PROTOBUF_NODISCARD std::string* release_message_b_for_k_w();
  void set_allocated_message_b_for_k_w(std::string* message_b_for_k_w);
  private:
  const std::string& _internal_message_b_for_k_w() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message_b_for_k_w(const std::string& value);
  std::string* _internal_mutable_message_b_for_k_w();
  public:

  // .safeheron.proto.PailAffRangeProof bob_proof_1 = 3;
  bool has_bob_proof_1() const;
  private:
  bool _internal_has_bob_proof_1() const;
  public:
  void clear_bob_proof_1();
  const ::safeheron::proto::PailAffRangeProof& bob_proof_1() const;
  PROTOBUF_NODISCARD ::safeheron::proto::PailAffRangeProof* release_bob_proof_1();
  ::safeheron::proto::PailAffRangeProof* mutable_bob_proof_1();
  void set_allocated_bob_proof_1(::safeheron::proto::PailAffRangeProof* bob_proof_1);
  private:
  const ::safeheron::proto::PailAffRangeProof& _internal_bob_proof_1() const;
  ::safeheron::proto::PailAffRangeProof* _internal_mutable_bob_proof_1();
  public:
  void unsafe_arena_set_allocated_bob_proof_1(
      ::safeheron::proto::PailAffRangeProof* bob_proof_1);
  ::safeheron::proto::PailAffRangeProof* unsafe_arena_release_bob_proof_1();

  // .safeheron.proto.PailAffGroupEleRangeProof_V1 bob_proof_2 = 4;
  bool has_bob_proof_2() const;
  private:
  bool _internal_has_bob_proof_2() const;
  public:
  void clear_bob_proof_2();
  const ::safeheron::proto::PailAffGroupEleRangeProof_V1& bob_proof_2() const;
  PROTOBUF_NODISCARD ::safeheron::proto::PailAffGroupEleRangeProof_V1* release_bob_proof_2();
  ::safeheron::proto::PailAffGroupEleRangeProof_V1* mutable_bob_proof_2();
  void set_allocated_bob_proof_2(::safeheron::proto::PailAffGroupEleRangeProof_V1* bob_proof_2);
  private:
  const ::safeheron::proto::PailAffGroupEleRangeProof_V1& _internal_bob_proof_2() const;
  ::safeheron::proto::PailAffGroupEleRangeProof_V1* _internal_mutable_bob_proof_2();
  public:
  void unsafe_arena_set_allocated_bob_proof_2(
      ::safeheron::proto::PailAffGroupEleRangeProof_V1* bob_proof_2);
  ::safeheron::proto::PailAffGroupEleRangeProof_V1* unsafe_arena_release_bob_proof_2();

  // @@protoc_insertion_point(class_scope:safeheron.proto.multi_party_ecdsa.gg20.sign.Round1P2PMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_b_for_k_gamma_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_b_for_k_w_;
  ::safeheron::proto::PailAffRangeProof* bob_proof_1_;
  ::safeheron::proto::PailAffGroupEleRangeProof_V1* bob_proof_2_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gg20_2fsign_2eproto;
};
// -------------------------------------------------------------------

class Round2BCMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:safeheron.proto.multi_party_ecdsa.gg20.sign.Round2BCMessage) */ {
 public:
  inline Round2BCMessage() : Round2BCMessage(nullptr) {}
  ~Round2BCMessage() override;
  explicit PROTOBUF_CONSTEXPR Round2BCMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Round2BCMessage(const Round2BCMessage& from);
  Round2BCMessage(Round2BCMessage&& from) noexcept
    : Round2BCMessage() {
    *this = ::std::move(from);
  }

  inline Round2BCMessage& operator=(const Round2BCMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline Round2BCMessage& operator=(Round2BCMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Round2BCMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const Round2BCMessage* internal_default_instance() {
    return reinterpret_cast<const Round2BCMessage*>(
               &_Round2BCMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Round2BCMessage& a, Round2BCMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(Round2BCMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Round2BCMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Round2BCMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Round2BCMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Round2BCMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Round2BCMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Round2BCMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safeheron.proto.multi_party_ecdsa.gg20.sign.Round2BCMessage";
  }
  protected:
  explicit Round2BCMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeltaFieldNumber = 1,
    kTFieldNumber = 2,
    kHFieldNumber = 3,
    kPedersenProofFieldNumber = 4,
  };
  // string delta = 1;
  void clear_delta();
  const std::string& delta() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_delta(ArgT0&& arg0, ArgT... args);
  std::string* mutable_delta();
  PROTOBUF_NODISCARD std::string* release_delta();
  void set_allocated_delta(std::string* delta);
  private:
  const std::string& _internal_delta() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_delta(const std::string& value);
  std::string* _internal_mutable_delta();
  public:

  // .safeheron.proto.CurvePoint T = 2;
  bool has_t() const;
  private:
  bool _internal_has_t() const;
  public:
  void clear_t();
  const ::safeheron::proto::CurvePoint& t() const;
  PROTOBUF_NODISCARD ::safeheron::proto::CurvePoint* release_t();
  ::safeheron::proto::CurvePoint* mutable_t();
  void set_allocated_t(::safeheron::proto::CurvePoint* t);
  private:
  const ::safeheron::proto::CurvePoint& _internal_t() const;
  ::safeheron::proto::CurvePoint* _internal_mutable_t();
  public:
  void unsafe_arena_set_allocated_t(
      ::safeheron::proto::CurvePoint* t);
  ::safeheron::proto::CurvePoint* unsafe_arena_release_t();

  // .safeheron.proto.CurvePoint H = 3;
  bool has_h() const;
  private:
  bool _internal_has_h() const;
  public:
  void clear_h();
  const ::safeheron::proto::CurvePoint& h() const;
  PROTOBUF_NODISCARD ::safeheron::proto::CurvePoint* release_h();
  ::safeheron::proto::CurvePoint* mutable_h();
  void set_allocated_h(::safeheron::proto::CurvePoint* h);
  private:
  const ::safeheron::proto::CurvePoint& _internal_h() const;
  ::safeheron::proto::CurvePoint* _internal_mutable_h();
  public:
  void unsafe_arena_set_allocated_h(
      ::safeheron::proto::CurvePoint* h);
  ::safeheron::proto::CurvePoint* unsafe_arena_release_h();

  // .safeheron.proto.PedersenProof pedersen_proof = 4;
  bool has_pedersen_proof() const;
  private:
  bool _internal_has_pedersen_proof() const;
  public:
  void clear_pedersen_proof();
  const ::safeheron::proto::PedersenProof& pedersen_proof() const;
  PROTOBUF_NODISCARD ::safeheron::proto::PedersenProof* release_pedersen_proof();
  ::safeheron::proto::PedersenProof* mutable_pedersen_proof();
  void set_allocated_pedersen_proof(::safeheron::proto::PedersenProof* pedersen_proof);
  private:
  const ::safeheron::proto::PedersenProof& _internal_pedersen_proof() const;
  ::safeheron::proto::PedersenProof* _internal_mutable_pedersen_proof();
  public:
  void unsafe_arena_set_allocated_pedersen_proof(
      ::safeheron::proto::PedersenProof* pedersen_proof);
  ::safeheron::proto::PedersenProof* unsafe_arena_release_pedersen_proof();

  // @@protoc_insertion_point(class_scope:safeheron.proto.multi_party_ecdsa.gg20.sign.Round2BCMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr delta_;
  ::safeheron::proto::CurvePoint* t_;
  ::safeheron::proto::CurvePoint* h_;
  ::safeheron::proto::PedersenProof* pedersen_proof_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gg20_2fsign_2eproto;
};
// -------------------------------------------------------------------

class Round3BCMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:safeheron.proto.multi_party_ecdsa.gg20.sign.Round3BCMessage) */ {
 public:
  inline Round3BCMessage() : Round3BCMessage(nullptr) {}
  ~Round3BCMessage() override;
  explicit PROTOBUF_CONSTEXPR Round3BCMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Round3BCMessage(const Round3BCMessage& from);
  Round3BCMessage(Round3BCMessage&& from) noexcept
    : Round3BCMessage() {
    *this = ::std::move(from);
  }

  inline Round3BCMessage& operator=(const Round3BCMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline Round3BCMessage& operator=(Round3BCMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Round3BCMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const Round3BCMessage* internal_default_instance() {
    return reinterpret_cast<const Round3BCMessage*>(
               &_Round3BCMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Round3BCMessage& a, Round3BCMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(Round3BCMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Round3BCMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Round3BCMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Round3BCMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Round3BCMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Round3BCMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Round3BCMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safeheron.proto.multi_party_ecdsa.gg20.sign.Round3BCMessage";
  }
  protected:
  explicit Round3BCMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlindFactorFieldNumber = 1,
    kGammaFieldNumber = 2,
  };
  // string blind_factor = 1;
  void clear_blind_factor();
  const std::string& blind_factor() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_blind_factor(ArgT0&& arg0, ArgT... args);
  std::string* mutable_blind_factor();
  PROTOBUF_NODISCARD std::string* release_blind_factor();
  void set_allocated_blind_factor(std::string* blind_factor);
  private:
  const std::string& _internal_blind_factor() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_blind_factor(const std::string& value);
  std::string* _internal_mutable_blind_factor();
  public:

  // .safeheron.proto.CurvePoint Gamma = 2;
  bool has_gamma() const;
  private:
  bool _internal_has_gamma() const;
  public:
  void clear_gamma();
  const ::safeheron::proto::CurvePoint& gamma() const;
  PROTOBUF_NODISCARD ::safeheron::proto::CurvePoint* release_gamma();
  ::safeheron::proto::CurvePoint* mutable_gamma();
  void set_allocated_gamma(::safeheron::proto::CurvePoint* gamma);
  private:
  const ::safeheron::proto::CurvePoint& _internal_gamma() const;
  ::safeheron::proto::CurvePoint* _internal_mutable_gamma();
  public:
  void unsafe_arena_set_allocated_gamma(
      ::safeheron::proto::CurvePoint* gamma);
  ::safeheron::proto::CurvePoint* unsafe_arena_release_gamma();

  // @@protoc_insertion_point(class_scope:safeheron.proto.multi_party_ecdsa.gg20.sign.Round3BCMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr blind_factor_;
  ::safeheron::proto::CurvePoint* gamma_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gg20_2fsign_2eproto;
};
// -------------------------------------------------------------------

class Round4BCMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:safeheron.proto.multi_party_ecdsa.gg20.sign.Round4BCMessage) */ {
 public:
  inline Round4BCMessage() : Round4BCMessage(nullptr) {}
  ~Round4BCMessage() override;
  explicit PROTOBUF_CONSTEXPR Round4BCMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Round4BCMessage(const Round4BCMessage& from);
  Round4BCMessage(Round4BCMessage&& from) noexcept
    : Round4BCMessage() {
    *this = ::std::move(from);
  }

  inline Round4BCMessage& operator=(const Round4BCMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline Round4BCMessage& operator=(Round4BCMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Round4BCMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const Round4BCMessage* internal_default_instance() {
    return reinterpret_cast<const Round4BCMessage*>(
               &_Round4BCMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Round4BCMessage& a, Round4BCMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(Round4BCMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Round4BCMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Round4BCMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Round4BCMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Round4BCMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Round4BCMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Round4BCMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safeheron.proto.multi_party_ecdsa.gg20.sign.Round4BCMessage";
  }
  protected:
  explicit Round4BCMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRFieldNumber = 1,
  };
  // .safeheron.proto.CurvePoint R = 1;
  bool has_r() const;
  private:
  bool _internal_has_r() const;
  public:
  void clear_r();
  const ::safeheron::proto::CurvePoint& r() const;
  PROTOBUF_NODISCARD ::safeheron::proto::CurvePoint* release_r();
  ::safeheron::proto::CurvePoint* mutable_r();
  void set_allocated_r(::safeheron::proto::CurvePoint* r);
  private:
  const ::safeheron::proto::CurvePoint& _internal_r() const;
  ::safeheron::proto::CurvePoint* _internal_mutable_r();
  public:
  void unsafe_arena_set_allocated_r(
      ::safeheron::proto::CurvePoint* r);
  ::safeheron::proto::CurvePoint* unsafe_arena_release_r();

  // @@protoc_insertion_point(class_scope:safeheron.proto.multi_party_ecdsa.gg20.sign.Round4BCMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::safeheron::proto::CurvePoint* r_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gg20_2fsign_2eproto;
};
// -------------------------------------------------------------------

class Round4P2PMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:safeheron.proto.multi_party_ecdsa.gg20.sign.Round4P2PMessage) */ {
 public:
  inline Round4P2PMessage() : Round4P2PMessage(nullptr) {}
  ~Round4P2PMessage() override;
  explicit PROTOBUF_CONSTEXPR Round4P2PMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Round4P2PMessage(const Round4P2PMessage& from);
  Round4P2PMessage(Round4P2PMessage&& from) noexcept
    : Round4P2PMessage() {
    *this = ::std::move(from);
  }

  inline Round4P2PMessage& operator=(const Round4P2PMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline Round4P2PMessage& operator=(Round4P2PMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Round4P2PMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const Round4P2PMessage* internal_default_instance() {
    return reinterpret_cast<const Round4P2PMessage*>(
               &_Round4P2PMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Round4P2PMessage& a, Round4P2PMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(Round4P2PMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Round4P2PMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Round4P2PMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Round4P2PMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Round4P2PMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Round4P2PMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Round4P2PMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safeheron.proto.multi_party_ecdsa.gg20.sign.Round4P2PMessage";
  }
  protected:
  explicit Round4P2PMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPailEncGroupEleProofFieldNumber = 2,
  };
  // .safeheron.proto.PailEncGroupEleRangeProof pail_enc_group_ele_proof = 2;
  bool has_pail_enc_group_ele_proof() const;
  private:
  bool _internal_has_pail_enc_group_ele_proof() const;
  public:
  void clear_pail_enc_group_ele_proof();
  const ::safeheron::proto::PailEncGroupEleRangeProof& pail_enc_group_ele_proof() const;
  PROTOBUF_NODISCARD ::safeheron::proto::PailEncGroupEleRangeProof* release_pail_enc_group_ele_proof();
  ::safeheron::proto::PailEncGroupEleRangeProof* mutable_pail_enc_group_ele_proof();
  void set_allocated_pail_enc_group_ele_proof(::safeheron::proto::PailEncGroupEleRangeProof* pail_enc_group_ele_proof);
  private:
  const ::safeheron::proto::PailEncGroupEleRangeProof& _internal_pail_enc_group_ele_proof() const;
  ::safeheron::proto::PailEncGroupEleRangeProof* _internal_mutable_pail_enc_group_ele_proof();
  public:
  void unsafe_arena_set_allocated_pail_enc_group_ele_proof(
      ::safeheron::proto::PailEncGroupEleRangeProof* pail_enc_group_ele_proof);
  ::safeheron::proto::PailEncGroupEleRangeProof* unsafe_arena_release_pail_enc_group_ele_proof();

  // @@protoc_insertion_point(class_scope:safeheron.proto.multi_party_ecdsa.gg20.sign.Round4P2PMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::safeheron::proto::PailEncGroupEleRangeProof* pail_enc_group_ele_proof_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gg20_2fsign_2eproto;
};
// -------------------------------------------------------------------

class Round5BCMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:safeheron.proto.multi_party_ecdsa.gg20.sign.Round5BCMessage) */ {
 public:
  inline Round5BCMessage() : Round5BCMessage(nullptr) {}
  ~Round5BCMessage() override;
  explicit PROTOBUF_CONSTEXPR Round5BCMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Round5BCMessage(const Round5BCMessage& from);
  Round5BCMessage(Round5BCMessage&& from) noexcept
    : Round5BCMessage() {
    *this = ::std::move(from);
  }

  inline Round5BCMessage& operator=(const Round5BCMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline Round5BCMessage& operator=(Round5BCMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Round5BCMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const Round5BCMessage* internal_default_instance() {
    return reinterpret_cast<const Round5BCMessage*>(
               &_Round5BCMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Round5BCMessage& a, Round5BCMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(Round5BCMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Round5BCMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Round5BCMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Round5BCMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Round5BCMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Round5BCMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Round5BCMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safeheron.proto.multi_party_ecdsa.gg20.sign.Round5BCMessage";
  }
  protected:
  explicit Round5BCMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSFieldNumber = 1,
    kHegProofFieldNumber = 2,
  };
  // .safeheron.proto.CurvePoint S = 1;
  bool has_s() const;
  private:
  bool _internal_has_s() const;
  public:
  void clear_s();
  const ::safeheron::proto::CurvePoint& s() const;
  PROTOBUF_NODISCARD ::safeheron::proto::CurvePoint* release_s();
  ::safeheron::proto::CurvePoint* mutable_s();
  void set_allocated_s(::safeheron::proto::CurvePoint* s);
  private:
  const ::safeheron::proto::CurvePoint& _internal_s() const;
  ::safeheron::proto::CurvePoint* _internal_mutable_s();
  public:
  void unsafe_arena_set_allocated_s(
      ::safeheron::proto::CurvePoint* s);
  ::safeheron::proto::CurvePoint* unsafe_arena_release_s();

  // .safeheron.proto.HEGProof_V3 heg_proof = 2;
  bool has_heg_proof() const;
  private:
  bool _internal_has_heg_proof() const;
  public:
  void clear_heg_proof();
  const ::safeheron::proto::HEGProof_V3& heg_proof() const;
  PROTOBUF_NODISCARD ::safeheron::proto::HEGProof_V3* release_heg_proof();
  ::safeheron::proto::HEGProof_V3* mutable_heg_proof();
  void set_allocated_heg_proof(::safeheron::proto::HEGProof_V3* heg_proof);
  private:
  const ::safeheron::proto::HEGProof_V3& _internal_heg_proof() const;
  ::safeheron::proto::HEGProof_V3* _internal_mutable_heg_proof();
  public:
  void unsafe_arena_set_allocated_heg_proof(
      ::safeheron::proto::HEGProof_V3* heg_proof);
  ::safeheron::proto::HEGProof_V3* unsafe_arena_release_heg_proof();

  // @@protoc_insertion_point(class_scope:safeheron.proto.multi_party_ecdsa.gg20.sign.Round5BCMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::safeheron::proto::CurvePoint* s_;
  ::safeheron::proto::HEGProof_V3* heg_proof_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gg20_2fsign_2eproto;
};
// -------------------------------------------------------------------

class Round6BCMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:safeheron.proto.multi_party_ecdsa.gg20.sign.Round6BCMessage) */ {
 public:
  inline Round6BCMessage() : Round6BCMessage(nullptr) {}
  ~Round6BCMessage() override;
  explicit PROTOBUF_CONSTEXPR Round6BCMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Round6BCMessage(const Round6BCMessage& from);
  Round6BCMessage(Round6BCMessage&& from) noexcept
    : Round6BCMessage() {
    *this = ::std::move(from);
  }

  inline Round6BCMessage& operator=(const Round6BCMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline Round6BCMessage& operator=(Round6BCMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Round6BCMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const Round6BCMessage* internal_default_instance() {
    return reinterpret_cast<const Round6BCMessage*>(
               &_Round6BCMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Round6BCMessage& a, Round6BCMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(Round6BCMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Round6BCMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Round6BCMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Round6BCMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Round6BCMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Round6BCMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Round6BCMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safeheron.proto.multi_party_ecdsa.gg20.sign.Round6BCMessage";
  }
  protected:
  explicit Round6BCMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSiFieldNumber = 1,
  };
  // string si = 1;
  void clear_si();
  const std::string& si() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_si(ArgT0&& arg0, ArgT... args);
  std::string* mutable_si();
  PROTOBUF_NODISCARD std::string* release_si();
  void set_allocated_si(std::string* si);
  private:
  const std::string& _internal_si() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_si(const std::string& value);
  std::string* _internal_mutable_si();
  public:

  // @@protoc_insertion_point(class_scope:safeheron.proto.multi_party_ecdsa.gg20.sign.Round6BCMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr si_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gg20_2fsign_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Round0BCMessage

// string message_a = 1;
inline void Round0BCMessage::clear_message_a() {
  message_a_.ClearToEmpty();
}
inline const std::string& Round0BCMessage::message_a() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.multi_party_ecdsa.gg20.sign.Round0BCMessage.message_a)
  return _internal_message_a();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Round0BCMessage::set_message_a(ArgT0&& arg0, ArgT... args) {
 
 message_a_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.multi_party_ecdsa.gg20.sign.Round0BCMessage.message_a)
}
inline std::string* Round0BCMessage::mutable_message_a() {
  std::string* _s = _internal_mutable_message_a();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.multi_party_ecdsa.gg20.sign.Round0BCMessage.message_a)
  return _s;
}
inline const std::string& Round0BCMessage::_internal_message_a() const {
  return message_a_.Get();
}
inline void Round0BCMessage::_internal_set_message_a(const std::string& value) {
  
  message_a_.Set(value, GetArenaForAllocation());
}
inline std::string* Round0BCMessage::_internal_mutable_message_a() {
  
  return message_a_.Mutable(GetArenaForAllocation());
}
inline std::string* Round0BCMessage::release_message_a() {
  // @@protoc_insertion_point(field_release:safeheron.proto.multi_party_ecdsa.gg20.sign.Round0BCMessage.message_a)
  return message_a_.Release();
}
inline void Round0BCMessage::set_allocated_message_a(std::string* message_a) {
  if (message_a != nullptr) {
    
  } else {
    
  }
  message_a_.SetAllocated(message_a, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (message_a_.IsDefault()) {
    message_a_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.multi_party_ecdsa.gg20.sign.Round0BCMessage.message_a)
}

// string commitment = 2;
inline void Round0BCMessage::clear_commitment() {
  commitment_.ClearToEmpty();
}
inline const std::string& Round0BCMessage::commitment() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.multi_party_ecdsa.gg20.sign.Round0BCMessage.commitment)
  return _internal_commitment();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Round0BCMessage::set_commitment(ArgT0&& arg0, ArgT... args) {
 
 commitment_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.multi_party_ecdsa.gg20.sign.Round0BCMessage.commitment)
}
inline std::string* Round0BCMessage::mutable_commitment() {
  std::string* _s = _internal_mutable_commitment();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.multi_party_ecdsa.gg20.sign.Round0BCMessage.commitment)
  return _s;
}
inline const std::string& Round0BCMessage::_internal_commitment() const {
  return commitment_.Get();
}
inline void Round0BCMessage::_internal_set_commitment(const std::string& value) {
  
  commitment_.Set(value, GetArenaForAllocation());
}
inline std::string* Round0BCMessage::_internal_mutable_commitment() {
  
  return commitment_.Mutable(GetArenaForAllocation());
}
inline std::string* Round0BCMessage::release_commitment() {
  // @@protoc_insertion_point(field_release:safeheron.proto.multi_party_ecdsa.gg20.sign.Round0BCMessage.commitment)
  return commitment_.Release();
}
inline void Round0BCMessage::set_allocated_commitment(std::string* commitment) {
  if (commitment != nullptr) {
    
  } else {
    
  }
  commitment_.SetAllocated(commitment, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (commitment_.IsDefault()) {
    commitment_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.multi_party_ecdsa.gg20.sign.Round0BCMessage.commitment)
}

// -------------------------------------------------------------------

// Round0P2PMessage

// .safeheron.proto.PailEncRangeProof_V1 alice_proof = 3;
inline bool Round0P2PMessage::_internal_has_alice_proof() const {
  return this != internal_default_instance() && alice_proof_ != nullptr;
}
inline bool Round0P2PMessage::has_alice_proof() const {
  return _internal_has_alice_proof();
}
inline const ::safeheron::proto::PailEncRangeProof_V1& Round0P2PMessage::_internal_alice_proof() const {
  const ::safeheron::proto::PailEncRangeProof_V1* p = alice_proof_;
  return p != nullptr ? *p : reinterpret_cast<const ::safeheron::proto::PailEncRangeProof_V1&>(
      ::safeheron::proto::_PailEncRangeProof_V1_default_instance_);
}
inline const ::safeheron::proto::PailEncRangeProof_V1& Round0P2PMessage::alice_proof() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.multi_party_ecdsa.gg20.sign.Round0P2PMessage.alice_proof)
  return _internal_alice_proof();
}
inline void Round0P2PMessage::unsafe_arena_set_allocated_alice_proof(
    ::safeheron::proto::PailEncRangeProof_V1* alice_proof) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(alice_proof_);
  }
  alice_proof_ = alice_proof;
  if (alice_proof) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:safeheron.proto.multi_party_ecdsa.gg20.sign.Round0P2PMessage.alice_proof)
}
inline ::safeheron::proto::PailEncRangeProof_V1* Round0P2PMessage::release_alice_proof() {
  
  ::safeheron::proto::PailEncRangeProof_V1* temp = alice_proof_;
  alice_proof_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::safeheron::proto::PailEncRangeProof_V1* Round0P2PMessage::unsafe_arena_release_alice_proof() {
  // @@protoc_insertion_point(field_release:safeheron.proto.multi_party_ecdsa.gg20.sign.Round0P2PMessage.alice_proof)
  
  ::safeheron::proto::PailEncRangeProof_V1* temp = alice_proof_;
  alice_proof_ = nullptr;
  return temp;
}
inline ::safeheron::proto::PailEncRangeProof_V1* Round0P2PMessage::_internal_mutable_alice_proof() {
  
  if (alice_proof_ == nullptr) {
    auto* p = CreateMaybeMessage<::safeheron::proto::PailEncRangeProof_V1>(GetArenaForAllocation());
    alice_proof_ = p;
  }
  return alice_proof_;
}
inline ::safeheron::proto::PailEncRangeProof_V1* Round0P2PMessage::mutable_alice_proof() {
  ::safeheron::proto::PailEncRangeProof_V1* _msg = _internal_mutable_alice_proof();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.multi_party_ecdsa.gg20.sign.Round0P2PMessage.alice_proof)
  return _msg;
}
inline void Round0P2PMessage::set_allocated_alice_proof(::safeheron::proto::PailEncRangeProof_V1* alice_proof) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(alice_proof_);
  }
  if (alice_proof) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(alice_proof));
    if (message_arena != submessage_arena) {
      alice_proof = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, alice_proof, submessage_arena);
    }
    
  } else {
    
  }
  alice_proof_ = alice_proof;
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.multi_party_ecdsa.gg20.sign.Round0P2PMessage.alice_proof)
}

// -------------------------------------------------------------------

// Round1P2PMessage

// string message_b_for_k_gamma = 1;
inline void Round1P2PMessage::clear_message_b_for_k_gamma() {
  message_b_for_k_gamma_.ClearToEmpty();
}
inline const std::string& Round1P2PMessage::message_b_for_k_gamma() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.multi_party_ecdsa.gg20.sign.Round1P2PMessage.message_b_for_k_gamma)
  return _internal_message_b_for_k_gamma();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Round1P2PMessage::set_message_b_for_k_gamma(ArgT0&& arg0, ArgT... args) {
 
 message_b_for_k_gamma_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.multi_party_ecdsa.gg20.sign.Round1P2PMessage.message_b_for_k_gamma)
}
inline std::string* Round1P2PMessage::mutable_message_b_for_k_gamma() {
  std::string* _s = _internal_mutable_message_b_for_k_gamma();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.multi_party_ecdsa.gg20.sign.Round1P2PMessage.message_b_for_k_gamma)
  return _s;
}
inline const std::string& Round1P2PMessage::_internal_message_b_for_k_gamma() const {
  return message_b_for_k_gamma_.Get();
}
inline void Round1P2PMessage::_internal_set_message_b_for_k_gamma(const std::string& value) {
  
  message_b_for_k_gamma_.Set(value, GetArenaForAllocation());
}
inline std::string* Round1P2PMessage::_internal_mutable_message_b_for_k_gamma() {
  
  return message_b_for_k_gamma_.Mutable(GetArenaForAllocation());
}
inline std::string* Round1P2PMessage::release_message_b_for_k_gamma() {
  // @@protoc_insertion_point(field_release:safeheron.proto.multi_party_ecdsa.gg20.sign.Round1P2PMessage.message_b_for_k_gamma)
  return message_b_for_k_gamma_.Release();
}
inline void Round1P2PMessage::set_allocated_message_b_for_k_gamma(std::string* message_b_for_k_gamma) {
  if (message_b_for_k_gamma != nullptr) {
    
  } else {
    
  }
  message_b_for_k_gamma_.SetAllocated(message_b_for_k_gamma, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (message_b_for_k_gamma_.IsDefault()) {
    message_b_for_k_gamma_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.multi_party_ecdsa.gg20.sign.Round1P2PMessage.message_b_for_k_gamma)
}

// string message_b_for_k_w = 2;
inline void Round1P2PMessage::clear_message_b_for_k_w() {
  message_b_for_k_w_.ClearToEmpty();
}
inline const std::string& Round1P2PMessage::message_b_for_k_w() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.multi_party_ecdsa.gg20.sign.Round1P2PMessage.message_b_for_k_w)
  return _internal_message_b_for_k_w();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Round1P2PMessage::set_message_b_for_k_w(ArgT0&& arg0, ArgT... args) {
 
 message_b_for_k_w_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.multi_party_ecdsa.gg20.sign.Round1P2PMessage.message_b_for_k_w)
}
inline std::string* Round1P2PMessage::mutable_message_b_for_k_w() {
  std::string* _s = _internal_mutable_message_b_for_k_w();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.multi_party_ecdsa.gg20.sign.Round1P2PMessage.message_b_for_k_w)
  return _s;
}
inline const std::string& Round1P2PMessage::_internal_message_b_for_k_w() const {
  return message_b_for_k_w_.Get();
}
inline void Round1P2PMessage::_internal_set_message_b_for_k_w(const std::string& value) {
  
  message_b_for_k_w_.Set(value, GetArenaForAllocation());
}
inline std::string* Round1P2PMessage::_internal_mutable_message_b_for_k_w() {
  
  return message_b_for_k_w_.Mutable(GetArenaForAllocation());
}
inline std::string* Round1P2PMessage::release_message_b_for_k_w() {
  // @@protoc_insertion_point(field_release:safeheron.proto.multi_party_ecdsa.gg20.sign.Round1P2PMessage.message_b_for_k_w)
  return message_b_for_k_w_.Release();
}
inline void Round1P2PMessage::set_allocated_message_b_for_k_w(std::string* message_b_for_k_w) {
  if (message_b_for_k_w != nullptr) {
    
  } else {
    
  }
  message_b_for_k_w_.SetAllocated(message_b_for_k_w, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (message_b_for_k_w_.IsDefault()) {
    message_b_for_k_w_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.multi_party_ecdsa.gg20.sign.Round1P2PMessage.message_b_for_k_w)
}

// .safeheron.proto.PailAffRangeProof bob_proof_1 = 3;
inline bool Round1P2PMessage::_internal_has_bob_proof_1() const {
  return this != internal_default_instance() && bob_proof_1_ != nullptr;
}
inline bool Round1P2PMessage::has_bob_proof_1() const {
  return _internal_has_bob_proof_1();
}
inline const ::safeheron::proto::PailAffRangeProof& Round1P2PMessage::_internal_bob_proof_1() const {
  const ::safeheron::proto::PailAffRangeProof* p = bob_proof_1_;
  return p != nullptr ? *p : reinterpret_cast<const ::safeheron::proto::PailAffRangeProof&>(
      ::safeheron::proto::_PailAffRangeProof_default_instance_);
}
inline const ::safeheron::proto::PailAffRangeProof& Round1P2PMessage::bob_proof_1() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.multi_party_ecdsa.gg20.sign.Round1P2PMessage.bob_proof_1)
  return _internal_bob_proof_1();
}
inline void Round1P2PMessage::unsafe_arena_set_allocated_bob_proof_1(
    ::safeheron::proto::PailAffRangeProof* bob_proof_1) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bob_proof_1_);
  }
  bob_proof_1_ = bob_proof_1;
  if (bob_proof_1) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:safeheron.proto.multi_party_ecdsa.gg20.sign.Round1P2PMessage.bob_proof_1)
}
inline ::safeheron::proto::PailAffRangeProof* Round1P2PMessage::release_bob_proof_1() {
  
  ::safeheron::proto::PailAffRangeProof* temp = bob_proof_1_;
  bob_proof_1_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::safeheron::proto::PailAffRangeProof* Round1P2PMessage::unsafe_arena_release_bob_proof_1() {
  // @@protoc_insertion_point(field_release:safeheron.proto.multi_party_ecdsa.gg20.sign.Round1P2PMessage.bob_proof_1)
  
  ::safeheron::proto::PailAffRangeProof* temp = bob_proof_1_;
  bob_proof_1_ = nullptr;
  return temp;
}
inline ::safeheron::proto::PailAffRangeProof* Round1P2PMessage::_internal_mutable_bob_proof_1() {
  
  if (bob_proof_1_ == nullptr) {
    auto* p = CreateMaybeMessage<::safeheron::proto::PailAffRangeProof>(GetArenaForAllocation());
    bob_proof_1_ = p;
  }
  return bob_proof_1_;
}
inline ::safeheron::proto::PailAffRangeProof* Round1P2PMessage::mutable_bob_proof_1() {
  ::safeheron::proto::PailAffRangeProof* _msg = _internal_mutable_bob_proof_1();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.multi_party_ecdsa.gg20.sign.Round1P2PMessage.bob_proof_1)
  return _msg;
}
inline void Round1P2PMessage::set_allocated_bob_proof_1(::safeheron::proto::PailAffRangeProof* bob_proof_1) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(bob_proof_1_);
  }
  if (bob_proof_1) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bob_proof_1));
    if (message_arena != submessage_arena) {
      bob_proof_1 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bob_proof_1, submessage_arena);
    }
    
  } else {
    
  }
  bob_proof_1_ = bob_proof_1;
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.multi_party_ecdsa.gg20.sign.Round1P2PMessage.bob_proof_1)
}

// .safeheron.proto.PailAffGroupEleRangeProof_V1 bob_proof_2 = 4;
inline bool Round1P2PMessage::_internal_has_bob_proof_2() const {
  return this != internal_default_instance() && bob_proof_2_ != nullptr;
}
inline bool Round1P2PMessage::has_bob_proof_2() const {
  return _internal_has_bob_proof_2();
}
inline const ::safeheron::proto::PailAffGroupEleRangeProof_V1& Round1P2PMessage::_internal_bob_proof_2() const {
  const ::safeheron::proto::PailAffGroupEleRangeProof_V1* p = bob_proof_2_;
  return p != nullptr ? *p : reinterpret_cast<const ::safeheron::proto::PailAffGroupEleRangeProof_V1&>(
      ::safeheron::proto::_PailAffGroupEleRangeProof_V1_default_instance_);
}
inline const ::safeheron::proto::PailAffGroupEleRangeProof_V1& Round1P2PMessage::bob_proof_2() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.multi_party_ecdsa.gg20.sign.Round1P2PMessage.bob_proof_2)
  return _internal_bob_proof_2();
}
inline void Round1P2PMessage::unsafe_arena_set_allocated_bob_proof_2(
    ::safeheron::proto::PailAffGroupEleRangeProof_V1* bob_proof_2) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bob_proof_2_);
  }
  bob_proof_2_ = bob_proof_2;
  if (bob_proof_2) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:safeheron.proto.multi_party_ecdsa.gg20.sign.Round1P2PMessage.bob_proof_2)
}
inline ::safeheron::proto::PailAffGroupEleRangeProof_V1* Round1P2PMessage::release_bob_proof_2() {
  
  ::safeheron::proto::PailAffGroupEleRangeProof_V1* temp = bob_proof_2_;
  bob_proof_2_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::safeheron::proto::PailAffGroupEleRangeProof_V1* Round1P2PMessage::unsafe_arena_release_bob_proof_2() {
  // @@protoc_insertion_point(field_release:safeheron.proto.multi_party_ecdsa.gg20.sign.Round1P2PMessage.bob_proof_2)
  
  ::safeheron::proto::PailAffGroupEleRangeProof_V1* temp = bob_proof_2_;
  bob_proof_2_ = nullptr;
  return temp;
}
inline ::safeheron::proto::PailAffGroupEleRangeProof_V1* Round1P2PMessage::_internal_mutable_bob_proof_2() {
  
  if (bob_proof_2_ == nullptr) {
    auto* p = CreateMaybeMessage<::safeheron::proto::PailAffGroupEleRangeProof_V1>(GetArenaForAllocation());
    bob_proof_2_ = p;
  }
  return bob_proof_2_;
}
inline ::safeheron::proto::PailAffGroupEleRangeProof_V1* Round1P2PMessage::mutable_bob_proof_2() {
  ::safeheron::proto::PailAffGroupEleRangeProof_V1* _msg = _internal_mutable_bob_proof_2();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.multi_party_ecdsa.gg20.sign.Round1P2PMessage.bob_proof_2)
  return _msg;
}
inline void Round1P2PMessage::set_allocated_bob_proof_2(::safeheron::proto::PailAffGroupEleRangeProof_V1* bob_proof_2) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(bob_proof_2_);
  }
  if (bob_proof_2) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bob_proof_2));
    if (message_arena != submessage_arena) {
      bob_proof_2 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bob_proof_2, submessage_arena);
    }
    
  } else {
    
  }
  bob_proof_2_ = bob_proof_2;
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.multi_party_ecdsa.gg20.sign.Round1P2PMessage.bob_proof_2)
}

// -------------------------------------------------------------------

// Round2BCMessage

// string delta = 1;
inline void Round2BCMessage::clear_delta() {
  delta_.ClearToEmpty();
}
inline const std::string& Round2BCMessage::delta() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.multi_party_ecdsa.gg20.sign.Round2BCMessage.delta)
  return _internal_delta();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Round2BCMessage::set_delta(ArgT0&& arg0, ArgT... args) {
 
 delta_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.multi_party_ecdsa.gg20.sign.Round2BCMessage.delta)
}
inline std::string* Round2BCMessage::mutable_delta() {
  std::string* _s = _internal_mutable_delta();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.multi_party_ecdsa.gg20.sign.Round2BCMessage.delta)
  return _s;
}
inline const std::string& Round2BCMessage::_internal_delta() const {
  return delta_.Get();
}
inline void Round2BCMessage::_internal_set_delta(const std::string& value) {
  
  delta_.Set(value, GetArenaForAllocation());
}
inline std::string* Round2BCMessage::_internal_mutable_delta() {
  
  return delta_.Mutable(GetArenaForAllocation());
}
inline std::string* Round2BCMessage::release_delta() {
  // @@protoc_insertion_point(field_release:safeheron.proto.multi_party_ecdsa.gg20.sign.Round2BCMessage.delta)
  return delta_.Release();
}
inline void Round2BCMessage::set_allocated_delta(std::string* delta) {
  if (delta != nullptr) {
    
  } else {
    
  }
  delta_.SetAllocated(delta, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (delta_.IsDefault()) {
    delta_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.multi_party_ecdsa.gg20.sign.Round2BCMessage.delta)
}

// .safeheron.proto.CurvePoint T = 2;
inline bool Round2BCMessage::_internal_has_t() const {
  return this != internal_default_instance() && t_ != nullptr;
}
inline bool Round2BCMessage::has_t() const {
  return _internal_has_t();
}
inline const ::safeheron::proto::CurvePoint& Round2BCMessage::_internal_t() const {
  const ::safeheron::proto::CurvePoint* p = t_;
  return p != nullptr ? *p : reinterpret_cast<const ::safeheron::proto::CurvePoint&>(
      ::safeheron::proto::_CurvePoint_default_instance_);
}
inline const ::safeheron::proto::CurvePoint& Round2BCMessage::t() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.multi_party_ecdsa.gg20.sign.Round2BCMessage.T)
  return _internal_t();
}
inline void Round2BCMessage::unsafe_arena_set_allocated_t(
    ::safeheron::proto::CurvePoint* t) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(t_);
  }
  t_ = t;
  if (t) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:safeheron.proto.multi_party_ecdsa.gg20.sign.Round2BCMessage.T)
}
inline ::safeheron::proto::CurvePoint* Round2BCMessage::release_t() {
  
  ::safeheron::proto::CurvePoint* temp = t_;
  t_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::safeheron::proto::CurvePoint* Round2BCMessage::unsafe_arena_release_t() {
  // @@protoc_insertion_point(field_release:safeheron.proto.multi_party_ecdsa.gg20.sign.Round2BCMessage.T)
  
  ::safeheron::proto::CurvePoint* temp = t_;
  t_ = nullptr;
  return temp;
}
inline ::safeheron::proto::CurvePoint* Round2BCMessage::_internal_mutable_t() {
  
  if (t_ == nullptr) {
    auto* p = CreateMaybeMessage<::safeheron::proto::CurvePoint>(GetArenaForAllocation());
    t_ = p;
  }
  return t_;
}
inline ::safeheron::proto::CurvePoint* Round2BCMessage::mutable_t() {
  ::safeheron::proto::CurvePoint* _msg = _internal_mutable_t();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.multi_party_ecdsa.gg20.sign.Round2BCMessage.T)
  return _msg;
}
inline void Round2BCMessage::set_allocated_t(::safeheron::proto::CurvePoint* t) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(t_);
  }
  if (t) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(t));
    if (message_arena != submessage_arena) {
      t = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, t, submessage_arena);
    }
    
  } else {
    
  }
  t_ = t;
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.multi_party_ecdsa.gg20.sign.Round2BCMessage.T)
}

// .safeheron.proto.CurvePoint H = 3;
inline bool Round2BCMessage::_internal_has_h() const {
  return this != internal_default_instance() && h_ != nullptr;
}
inline bool Round2BCMessage::has_h() const {
  return _internal_has_h();
}
inline const ::safeheron::proto::CurvePoint& Round2BCMessage::_internal_h() const {
  const ::safeheron::proto::CurvePoint* p = h_;
  return p != nullptr ? *p : reinterpret_cast<const ::safeheron::proto::CurvePoint&>(
      ::safeheron::proto::_CurvePoint_default_instance_);
}
inline const ::safeheron::proto::CurvePoint& Round2BCMessage::h() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.multi_party_ecdsa.gg20.sign.Round2BCMessage.H)
  return _internal_h();
}
inline void Round2BCMessage::unsafe_arena_set_allocated_h(
    ::safeheron::proto::CurvePoint* h) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(h_);
  }
  h_ = h;
  if (h) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:safeheron.proto.multi_party_ecdsa.gg20.sign.Round2BCMessage.H)
}
inline ::safeheron::proto::CurvePoint* Round2BCMessage::release_h() {
  
  ::safeheron::proto::CurvePoint* temp = h_;
  h_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::safeheron::proto::CurvePoint* Round2BCMessage::unsafe_arena_release_h() {
  // @@protoc_insertion_point(field_release:safeheron.proto.multi_party_ecdsa.gg20.sign.Round2BCMessage.H)
  
  ::safeheron::proto::CurvePoint* temp = h_;
  h_ = nullptr;
  return temp;
}
inline ::safeheron::proto::CurvePoint* Round2BCMessage::_internal_mutable_h() {
  
  if (h_ == nullptr) {
    auto* p = CreateMaybeMessage<::safeheron::proto::CurvePoint>(GetArenaForAllocation());
    h_ = p;
  }
  return h_;
}
inline ::safeheron::proto::CurvePoint* Round2BCMessage::mutable_h() {
  ::safeheron::proto::CurvePoint* _msg = _internal_mutable_h();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.multi_party_ecdsa.gg20.sign.Round2BCMessage.H)
  return _msg;
}
inline void Round2BCMessage::set_allocated_h(::safeheron::proto::CurvePoint* h) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(h_);
  }
  if (h) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(h));
    if (message_arena != submessage_arena) {
      h = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, h, submessage_arena);
    }
    
  } else {
    
  }
  h_ = h;
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.multi_party_ecdsa.gg20.sign.Round2BCMessage.H)
}

// .safeheron.proto.PedersenProof pedersen_proof = 4;
inline bool Round2BCMessage::_internal_has_pedersen_proof() const {
  return this != internal_default_instance() && pedersen_proof_ != nullptr;
}
inline bool Round2BCMessage::has_pedersen_proof() const {
  return _internal_has_pedersen_proof();
}
inline const ::safeheron::proto::PedersenProof& Round2BCMessage::_internal_pedersen_proof() const {
  const ::safeheron::proto::PedersenProof* p = pedersen_proof_;
  return p != nullptr ? *p : reinterpret_cast<const ::safeheron::proto::PedersenProof&>(
      ::safeheron::proto::_PedersenProof_default_instance_);
}
inline const ::safeheron::proto::PedersenProof& Round2BCMessage::pedersen_proof() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.multi_party_ecdsa.gg20.sign.Round2BCMessage.pedersen_proof)
  return _internal_pedersen_proof();
}
inline void Round2BCMessage::unsafe_arena_set_allocated_pedersen_proof(
    ::safeheron::proto::PedersenProof* pedersen_proof) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pedersen_proof_);
  }
  pedersen_proof_ = pedersen_proof;
  if (pedersen_proof) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:safeheron.proto.multi_party_ecdsa.gg20.sign.Round2BCMessage.pedersen_proof)
}
inline ::safeheron::proto::PedersenProof* Round2BCMessage::release_pedersen_proof() {
  
  ::safeheron::proto::PedersenProof* temp = pedersen_proof_;
  pedersen_proof_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::safeheron::proto::PedersenProof* Round2BCMessage::unsafe_arena_release_pedersen_proof() {
  // @@protoc_insertion_point(field_release:safeheron.proto.multi_party_ecdsa.gg20.sign.Round2BCMessage.pedersen_proof)
  
  ::safeheron::proto::PedersenProof* temp = pedersen_proof_;
  pedersen_proof_ = nullptr;
  return temp;
}
inline ::safeheron::proto::PedersenProof* Round2BCMessage::_internal_mutable_pedersen_proof() {
  
  if (pedersen_proof_ == nullptr) {
    auto* p = CreateMaybeMessage<::safeheron::proto::PedersenProof>(GetArenaForAllocation());
    pedersen_proof_ = p;
  }
  return pedersen_proof_;
}
inline ::safeheron::proto::PedersenProof* Round2BCMessage::mutable_pedersen_proof() {
  ::safeheron::proto::PedersenProof* _msg = _internal_mutable_pedersen_proof();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.multi_party_ecdsa.gg20.sign.Round2BCMessage.pedersen_proof)
  return _msg;
}
inline void Round2BCMessage::set_allocated_pedersen_proof(::safeheron::proto::PedersenProof* pedersen_proof) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(pedersen_proof_);
  }
  if (pedersen_proof) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pedersen_proof));
    if (message_arena != submessage_arena) {
      pedersen_proof = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pedersen_proof, submessage_arena);
    }
    
  } else {
    
  }
  pedersen_proof_ = pedersen_proof;
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.multi_party_ecdsa.gg20.sign.Round2BCMessage.pedersen_proof)
}

// -------------------------------------------------------------------

// Round3BCMessage

// string blind_factor = 1;
inline void Round3BCMessage::clear_blind_factor() {
  blind_factor_.ClearToEmpty();
}
inline const std::string& Round3BCMessage::blind_factor() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.multi_party_ecdsa.gg20.sign.Round3BCMessage.blind_factor)
  return _internal_blind_factor();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Round3BCMessage::set_blind_factor(ArgT0&& arg0, ArgT... args) {
 
 blind_factor_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.multi_party_ecdsa.gg20.sign.Round3BCMessage.blind_factor)
}
inline std::string* Round3BCMessage::mutable_blind_factor() {
  std::string* _s = _internal_mutable_blind_factor();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.multi_party_ecdsa.gg20.sign.Round3BCMessage.blind_factor)
  return _s;
}
inline const std::string& Round3BCMessage::_internal_blind_factor() const {
  return blind_factor_.Get();
}
inline void Round3BCMessage::_internal_set_blind_factor(const std::string& value) {
  
  blind_factor_.Set(value, GetArenaForAllocation());
}
inline std::string* Round3BCMessage::_internal_mutable_blind_factor() {
  
  return blind_factor_.Mutable(GetArenaForAllocation());
}
inline std::string* Round3BCMessage::release_blind_factor() {
  // @@protoc_insertion_point(field_release:safeheron.proto.multi_party_ecdsa.gg20.sign.Round3BCMessage.blind_factor)
  return blind_factor_.Release();
}
inline void Round3BCMessage::set_allocated_blind_factor(std::string* blind_factor) {
  if (blind_factor != nullptr) {
    
  } else {
    
  }
  blind_factor_.SetAllocated(blind_factor, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (blind_factor_.IsDefault()) {
    blind_factor_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.multi_party_ecdsa.gg20.sign.Round3BCMessage.blind_factor)
}

// .safeheron.proto.CurvePoint Gamma = 2;
inline bool Round3BCMessage::_internal_has_gamma() const {
  return this != internal_default_instance() && gamma_ != nullptr;
}
inline bool Round3BCMessage::has_gamma() const {
  return _internal_has_gamma();
}
inline const ::safeheron::proto::CurvePoint& Round3BCMessage::_internal_gamma() const {
  const ::safeheron::proto::CurvePoint* p = gamma_;
  return p != nullptr ? *p : reinterpret_cast<const ::safeheron::proto::CurvePoint&>(
      ::safeheron::proto::_CurvePoint_default_instance_);
}
inline const ::safeheron::proto::CurvePoint& Round3BCMessage::gamma() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.multi_party_ecdsa.gg20.sign.Round3BCMessage.Gamma)
  return _internal_gamma();
}
inline void Round3BCMessage::unsafe_arena_set_allocated_gamma(
    ::safeheron::proto::CurvePoint* gamma) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(gamma_);
  }
  gamma_ = gamma;
  if (gamma) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:safeheron.proto.multi_party_ecdsa.gg20.sign.Round3BCMessage.Gamma)
}
inline ::safeheron::proto::CurvePoint* Round3BCMessage::release_gamma() {
  
  ::safeheron::proto::CurvePoint* temp = gamma_;
  gamma_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::safeheron::proto::CurvePoint* Round3BCMessage::unsafe_arena_release_gamma() {
  // @@protoc_insertion_point(field_release:safeheron.proto.multi_party_ecdsa.gg20.sign.Round3BCMessage.Gamma)
  
  ::safeheron::proto::CurvePoint* temp = gamma_;
  gamma_ = nullptr;
  return temp;
}
inline ::safeheron::proto::CurvePoint* Round3BCMessage::_internal_mutable_gamma() {
  
  if (gamma_ == nullptr) {
    auto* p = CreateMaybeMessage<::safeheron::proto::CurvePoint>(GetArenaForAllocation());
    gamma_ = p;
  }
  return gamma_;
}
inline ::safeheron::proto::CurvePoint* Round3BCMessage::mutable_gamma() {
  ::safeheron::proto::CurvePoint* _msg = _internal_mutable_gamma();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.multi_party_ecdsa.gg20.sign.Round3BCMessage.Gamma)
  return _msg;
}
inline void Round3BCMessage::set_allocated_gamma(::safeheron::proto::CurvePoint* gamma) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(gamma_);
  }
  if (gamma) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(gamma));
    if (message_arena != submessage_arena) {
      gamma = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gamma, submessage_arena);
    }
    
  } else {
    
  }
  gamma_ = gamma;
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.multi_party_ecdsa.gg20.sign.Round3BCMessage.Gamma)
}

// -------------------------------------------------------------------

// Round4BCMessage

// .safeheron.proto.CurvePoint R = 1;
inline bool Round4BCMessage::_internal_has_r() const {
  return this != internal_default_instance() && r_ != nullptr;
}
inline bool Round4BCMessage::has_r() const {
  return _internal_has_r();
}
inline const ::safeheron::proto::CurvePoint& Round4BCMessage::_internal_r() const {
  const ::safeheron::proto::CurvePoint* p = r_;
  return p != nullptr ? *p : reinterpret_cast<const ::safeheron::proto::CurvePoint&>(
      ::safeheron::proto::_CurvePoint_default_instance_);
}
inline const ::safeheron::proto::CurvePoint& Round4BCMessage::r() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.multi_party_ecdsa.gg20.sign.Round4BCMessage.R)
  return _internal_r();
}
inline void Round4BCMessage::unsafe_arena_set_allocated_r(
    ::safeheron::proto::CurvePoint* r) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(r_);
  }
  r_ = r;
  if (r) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:safeheron.proto.multi_party_ecdsa.gg20.sign.Round4BCMessage.R)
}
inline ::safeheron::proto::CurvePoint* Round4BCMessage::release_r() {
  
  ::safeheron::proto::CurvePoint* temp = r_;
  r_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::safeheron::proto::CurvePoint* Round4BCMessage::unsafe_arena_release_r() {
  // @@protoc_insertion_point(field_release:safeheron.proto.multi_party_ecdsa.gg20.sign.Round4BCMessage.R)
  
  ::safeheron::proto::CurvePoint* temp = r_;
  r_ = nullptr;
  return temp;
}
inline ::safeheron::proto::CurvePoint* Round4BCMessage::_internal_mutable_r() {
  
  if (r_ == nullptr) {
    auto* p = CreateMaybeMessage<::safeheron::proto::CurvePoint>(GetArenaForAllocation());
    r_ = p;
  }
  return r_;
}
inline ::safeheron::proto::CurvePoint* Round4BCMessage::mutable_r() {
  ::safeheron::proto::CurvePoint* _msg = _internal_mutable_r();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.multi_party_ecdsa.gg20.sign.Round4BCMessage.R)
  return _msg;
}
inline void Round4BCMessage::set_allocated_r(::safeheron::proto::CurvePoint* r) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(r_);
  }
  if (r) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(r));
    if (message_arena != submessage_arena) {
      r = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, r, submessage_arena);
    }
    
  } else {
    
  }
  r_ = r;
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.multi_party_ecdsa.gg20.sign.Round4BCMessage.R)
}

// -------------------------------------------------------------------

// Round4P2PMessage

// .safeheron.proto.PailEncGroupEleRangeProof pail_enc_group_ele_proof = 2;
inline bool Round4P2PMessage::_internal_has_pail_enc_group_ele_proof() const {
  return this != internal_default_instance() && pail_enc_group_ele_proof_ != nullptr;
}
inline bool Round4P2PMessage::has_pail_enc_group_ele_proof() const {
  return _internal_has_pail_enc_group_ele_proof();
}
inline const ::safeheron::proto::PailEncGroupEleRangeProof& Round4P2PMessage::_internal_pail_enc_group_ele_proof() const {
  const ::safeheron::proto::PailEncGroupEleRangeProof* p = pail_enc_group_ele_proof_;
  return p != nullptr ? *p : reinterpret_cast<const ::safeheron::proto::PailEncGroupEleRangeProof&>(
      ::safeheron::proto::_PailEncGroupEleRangeProof_default_instance_);
}
inline const ::safeheron::proto::PailEncGroupEleRangeProof& Round4P2PMessage::pail_enc_group_ele_proof() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.multi_party_ecdsa.gg20.sign.Round4P2PMessage.pail_enc_group_ele_proof)
  return _internal_pail_enc_group_ele_proof();
}
inline void Round4P2PMessage::unsafe_arena_set_allocated_pail_enc_group_ele_proof(
    ::safeheron::proto::PailEncGroupEleRangeProof* pail_enc_group_ele_proof) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pail_enc_group_ele_proof_);
  }
  pail_enc_group_ele_proof_ = pail_enc_group_ele_proof;
  if (pail_enc_group_ele_proof) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:safeheron.proto.multi_party_ecdsa.gg20.sign.Round4P2PMessage.pail_enc_group_ele_proof)
}
inline ::safeheron::proto::PailEncGroupEleRangeProof* Round4P2PMessage::release_pail_enc_group_ele_proof() {
  
  ::safeheron::proto::PailEncGroupEleRangeProof* temp = pail_enc_group_ele_proof_;
  pail_enc_group_ele_proof_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::safeheron::proto::PailEncGroupEleRangeProof* Round4P2PMessage::unsafe_arena_release_pail_enc_group_ele_proof() {
  // @@protoc_insertion_point(field_release:safeheron.proto.multi_party_ecdsa.gg20.sign.Round4P2PMessage.pail_enc_group_ele_proof)
  
  ::safeheron::proto::PailEncGroupEleRangeProof* temp = pail_enc_group_ele_proof_;
  pail_enc_group_ele_proof_ = nullptr;
  return temp;
}
inline ::safeheron::proto::PailEncGroupEleRangeProof* Round4P2PMessage::_internal_mutable_pail_enc_group_ele_proof() {
  
  if (pail_enc_group_ele_proof_ == nullptr) {
    auto* p = CreateMaybeMessage<::safeheron::proto::PailEncGroupEleRangeProof>(GetArenaForAllocation());
    pail_enc_group_ele_proof_ = p;
  }
  return pail_enc_group_ele_proof_;
}
inline ::safeheron::proto::PailEncGroupEleRangeProof* Round4P2PMessage::mutable_pail_enc_group_ele_proof() {
  ::safeheron::proto::PailEncGroupEleRangeProof* _msg = _internal_mutable_pail_enc_group_ele_proof();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.multi_party_ecdsa.gg20.sign.Round4P2PMessage.pail_enc_group_ele_proof)
  return _msg;
}
inline void Round4P2PMessage::set_allocated_pail_enc_group_ele_proof(::safeheron::proto::PailEncGroupEleRangeProof* pail_enc_group_ele_proof) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(pail_enc_group_ele_proof_);
  }
  if (pail_enc_group_ele_proof) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pail_enc_group_ele_proof));
    if (message_arena != submessage_arena) {
      pail_enc_group_ele_proof = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pail_enc_group_ele_proof, submessage_arena);
    }
    
  } else {
    
  }
  pail_enc_group_ele_proof_ = pail_enc_group_ele_proof;
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.multi_party_ecdsa.gg20.sign.Round4P2PMessage.pail_enc_group_ele_proof)
}

// -------------------------------------------------------------------

// Round5BCMessage

// .safeheron.proto.CurvePoint S = 1;
inline bool Round5BCMessage::_internal_has_s() const {
  return this != internal_default_instance() && s_ != nullptr;
}
inline bool Round5BCMessage::has_s() const {
  return _internal_has_s();
}
inline const ::safeheron::proto::CurvePoint& Round5BCMessage::_internal_s() const {
  const ::safeheron::proto::CurvePoint* p = s_;
  return p != nullptr ? *p : reinterpret_cast<const ::safeheron::proto::CurvePoint&>(
      ::safeheron::proto::_CurvePoint_default_instance_);
}
inline const ::safeheron::proto::CurvePoint& Round5BCMessage::s() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.multi_party_ecdsa.gg20.sign.Round5BCMessage.S)
  return _internal_s();
}
inline void Round5BCMessage::unsafe_arena_set_allocated_s(
    ::safeheron::proto::CurvePoint* s) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(s_);
  }
  s_ = s;
  if (s) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:safeheron.proto.multi_party_ecdsa.gg20.sign.Round5BCMessage.S)
}
inline ::safeheron::proto::CurvePoint* Round5BCMessage::release_s() {
  
  ::safeheron::proto::CurvePoint* temp = s_;
  s_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::safeheron::proto::CurvePoint* Round5BCMessage::unsafe_arena_release_s() {
  // @@protoc_insertion_point(field_release:safeheron.proto.multi_party_ecdsa.gg20.sign.Round5BCMessage.S)
  
  ::safeheron::proto::CurvePoint* temp = s_;
  s_ = nullptr;
  return temp;
}
inline ::safeheron::proto::CurvePoint* Round5BCMessage::_internal_mutable_s() {
  
  if (s_ == nullptr) {
    auto* p = CreateMaybeMessage<::safeheron::proto::CurvePoint>(GetArenaForAllocation());
    s_ = p;
  }
  return s_;
}
inline ::safeheron::proto::CurvePoint* Round5BCMessage::mutable_s() {
  ::safeheron::proto::CurvePoint* _msg = _internal_mutable_s();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.multi_party_ecdsa.gg20.sign.Round5BCMessage.S)
  return _msg;
}
inline void Round5BCMessage::set_allocated_s(::safeheron::proto::CurvePoint* s) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(s_);
  }
  if (s) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(s));
    if (message_arena != submessage_arena) {
      s = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, s, submessage_arena);
    }
    
  } else {
    
  }
  s_ = s;
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.multi_party_ecdsa.gg20.sign.Round5BCMessage.S)
}

// .safeheron.proto.HEGProof_V3 heg_proof = 2;
inline bool Round5BCMessage::_internal_has_heg_proof() const {
  return this != internal_default_instance() && heg_proof_ != nullptr;
}
inline bool Round5BCMessage::has_heg_proof() const {
  return _internal_has_heg_proof();
}
inline const ::safeheron::proto::HEGProof_V3& Round5BCMessage::_internal_heg_proof() const {
  const ::safeheron::proto::HEGProof_V3* p = heg_proof_;
  return p != nullptr ? *p : reinterpret_cast<const ::safeheron::proto::HEGProof_V3&>(
      ::safeheron::proto::_HEGProof_V3_default_instance_);
}
inline const ::safeheron::proto::HEGProof_V3& Round5BCMessage::heg_proof() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.multi_party_ecdsa.gg20.sign.Round5BCMessage.heg_proof)
  return _internal_heg_proof();
}
inline void Round5BCMessage::unsafe_arena_set_allocated_heg_proof(
    ::safeheron::proto::HEGProof_V3* heg_proof) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(heg_proof_);
  }
  heg_proof_ = heg_proof;
  if (heg_proof) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:safeheron.proto.multi_party_ecdsa.gg20.sign.Round5BCMessage.heg_proof)
}
inline ::safeheron::proto::HEGProof_V3* Round5BCMessage::release_heg_proof() {
  
  ::safeheron::proto::HEGProof_V3* temp = heg_proof_;
  heg_proof_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::safeheron::proto::HEGProof_V3* Round5BCMessage::unsafe_arena_release_heg_proof() {
  // @@protoc_insertion_point(field_release:safeheron.proto.multi_party_ecdsa.gg20.sign.Round5BCMessage.heg_proof)
  
  ::safeheron::proto::HEGProof_V3* temp = heg_proof_;
  heg_proof_ = nullptr;
  return temp;
}
inline ::safeheron::proto::HEGProof_V3* Round5BCMessage::_internal_mutable_heg_proof() {
  
  if (heg_proof_ == nullptr) {
    auto* p = CreateMaybeMessage<::safeheron::proto::HEGProof_V3>(GetArenaForAllocation());
    heg_proof_ = p;
  }
  return heg_proof_;
}
inline ::safeheron::proto::HEGProof_V3* Round5BCMessage::mutable_heg_proof() {
  ::safeheron::proto::HEGProof_V3* _msg = _internal_mutable_heg_proof();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.multi_party_ecdsa.gg20.sign.Round5BCMessage.heg_proof)
  return _msg;
}
inline void Round5BCMessage::set_allocated_heg_proof(::safeheron::proto::HEGProof_V3* heg_proof) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(heg_proof_);
  }
  if (heg_proof) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(heg_proof));
    if (message_arena != submessage_arena) {
      heg_proof = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, heg_proof, submessage_arena);
    }
    
  } else {
    
  }
  heg_proof_ = heg_proof;
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.multi_party_ecdsa.gg20.sign.Round5BCMessage.heg_proof)
}

// -------------------------------------------------------------------

// Round6BCMessage

// string si = 1;
inline void Round6BCMessage::clear_si() {
  si_.ClearToEmpty();
}
inline const std::string& Round6BCMessage::si() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.multi_party_ecdsa.gg20.sign.Round6BCMessage.si)
  return _internal_si();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Round6BCMessage::set_si(ArgT0&& arg0, ArgT... args) {
 
 si_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.multi_party_ecdsa.gg20.sign.Round6BCMessage.si)
}
inline std::string* Round6BCMessage::mutable_si() {
  std::string* _s = _internal_mutable_si();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.multi_party_ecdsa.gg20.sign.Round6BCMessage.si)
  return _s;
}
inline const std::string& Round6BCMessage::_internal_si() const {
  return si_.Get();
}
inline void Round6BCMessage::_internal_set_si(const std::string& value) {
  
  si_.Set(value, GetArenaForAllocation());
}
inline std::string* Round6BCMessage::_internal_mutable_si() {
  
  return si_.Mutable(GetArenaForAllocation());
}
inline std::string* Round6BCMessage::release_si() {
  // @@protoc_insertion_point(field_release:safeheron.proto.multi_party_ecdsa.gg20.sign.Round6BCMessage.si)
  return si_.Release();
}
inline void Round6BCMessage::set_allocated_si(std::string* si) {
  if (si != nullptr) {
    
  } else {
    
  }
  si_.SetAllocated(si, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (si_.IsDefault()) {
    si_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.multi_party_ecdsa.gg20.sign.Round6BCMessage.si)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace sign
}  // namespace gg20
}  // namespace multi_party_ecdsa
}  // namespace proto
}  // namespace safeheron

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_gg20_2fsign_2eproto
