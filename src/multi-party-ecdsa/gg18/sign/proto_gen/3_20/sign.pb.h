// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: gg18/sign.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_gg18_2fsign_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_gg18_2fsign_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "crypto-suites/crypto-curve/proto_gen/curve_point.pb.switch.h"
#include "crypto-suites/crypto-zkp/proto_gen/zkp.pb.switch.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_gg18_2fsign_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_gg18_2fsign_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_gg18_2fsign_2eproto;
namespace safeheron {
namespace proto {
namespace multi_party_ecdsa {
namespace gg18 {
namespace sign {
class Round0BCMessage;
struct Round0BCMessageDefaultTypeInternal;
extern Round0BCMessageDefaultTypeInternal _Round0BCMessage_default_instance_;
class Round0P2PMessage;
struct Round0P2PMessageDefaultTypeInternal;
extern Round0P2PMessageDefaultTypeInternal _Round0P2PMessage_default_instance_;
class Round1P2PMessage;
struct Round1P2PMessageDefaultTypeInternal;
extern Round1P2PMessageDefaultTypeInternal _Round1P2PMessage_default_instance_;
class Round2BCMessage;
struct Round2BCMessageDefaultTypeInternal;
extern Round2BCMessageDefaultTypeInternal _Round2BCMessage_default_instance_;
class Round3BCMessage;
struct Round3BCMessageDefaultTypeInternal;
extern Round3BCMessageDefaultTypeInternal _Round3BCMessage_default_instance_;
class Round4BCMessage;
struct Round4BCMessageDefaultTypeInternal;
extern Round4BCMessageDefaultTypeInternal _Round4BCMessage_default_instance_;
class Round5BCMessage;
struct Round5BCMessageDefaultTypeInternal;
extern Round5BCMessageDefaultTypeInternal _Round5BCMessage_default_instance_;
class Round6BCMessage;
struct Round6BCMessageDefaultTypeInternal;
extern Round6BCMessageDefaultTypeInternal _Round6BCMessage_default_instance_;
class Round7BCMessage;
struct Round7BCMessageDefaultTypeInternal;
extern Round7BCMessageDefaultTypeInternal _Round7BCMessage_default_instance_;
class Round8BCMessage;
struct Round8BCMessageDefaultTypeInternal;
extern Round8BCMessageDefaultTypeInternal _Round8BCMessage_default_instance_;
}  // namespace sign
}  // namespace gg18
}  // namespace multi_party_ecdsa
}  // namespace proto
}  // namespace safeheron
PROTOBUF_NAMESPACE_OPEN
template<> ::safeheron::proto::multi_party_ecdsa::gg18::sign::Round0BCMessage* Arena::CreateMaybeMessage<::safeheron::proto::multi_party_ecdsa::gg18::sign::Round0BCMessage>(Arena*);
template<> ::safeheron::proto::multi_party_ecdsa::gg18::sign::Round0P2PMessage* Arena::CreateMaybeMessage<::safeheron::proto::multi_party_ecdsa::gg18::sign::Round0P2PMessage>(Arena*);
template<> ::safeheron::proto::multi_party_ecdsa::gg18::sign::Round1P2PMessage* Arena::CreateMaybeMessage<::safeheron::proto::multi_party_ecdsa::gg18::sign::Round1P2PMessage>(Arena*);
template<> ::safeheron::proto::multi_party_ecdsa::gg18::sign::Round2BCMessage* Arena::CreateMaybeMessage<::safeheron::proto::multi_party_ecdsa::gg18::sign::Round2BCMessage>(Arena*);
template<> ::safeheron::proto::multi_party_ecdsa::gg18::sign::Round3BCMessage* Arena::CreateMaybeMessage<::safeheron::proto::multi_party_ecdsa::gg18::sign::Round3BCMessage>(Arena*);
template<> ::safeheron::proto::multi_party_ecdsa::gg18::sign::Round4BCMessage* Arena::CreateMaybeMessage<::safeheron::proto::multi_party_ecdsa::gg18::sign::Round4BCMessage>(Arena*);
template<> ::safeheron::proto::multi_party_ecdsa::gg18::sign::Round5BCMessage* Arena::CreateMaybeMessage<::safeheron::proto::multi_party_ecdsa::gg18::sign::Round5BCMessage>(Arena*);
template<> ::safeheron::proto::multi_party_ecdsa::gg18::sign::Round6BCMessage* Arena::CreateMaybeMessage<::safeheron::proto::multi_party_ecdsa::gg18::sign::Round6BCMessage>(Arena*);
template<> ::safeheron::proto::multi_party_ecdsa::gg18::sign::Round7BCMessage* Arena::CreateMaybeMessage<::safeheron::proto::multi_party_ecdsa::gg18::sign::Round7BCMessage>(Arena*);
template<> ::safeheron::proto::multi_party_ecdsa::gg18::sign::Round8BCMessage* Arena::CreateMaybeMessage<::safeheron::proto::multi_party_ecdsa::gg18::sign::Round8BCMessage>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace safeheron {
namespace proto {
namespace multi_party_ecdsa {
namespace gg18 {
namespace sign {

// ===================================================================

class Round0BCMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:safeheron.proto.multi_party_ecdsa.gg18.sign.Round0BCMessage) */ {
 public:
  inline Round0BCMessage() : Round0BCMessage(nullptr) {}
  ~Round0BCMessage() override;
  explicit PROTOBUF_CONSTEXPR Round0BCMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Round0BCMessage(const Round0BCMessage& from);
  Round0BCMessage(Round0BCMessage&& from) noexcept
    : Round0BCMessage() {
    *this = ::std::move(from);
  }

  inline Round0BCMessage& operator=(const Round0BCMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline Round0BCMessage& operator=(Round0BCMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Round0BCMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const Round0BCMessage* internal_default_instance() {
    return reinterpret_cast<const Round0BCMessage*>(
               &_Round0BCMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Round0BCMessage& a, Round0BCMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(Round0BCMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Round0BCMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Round0BCMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Round0BCMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Round0BCMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Round0BCMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Round0BCMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safeheron.proto.multi_party_ecdsa.gg18.sign.Round0BCMessage";
  }
  protected:
  explicit Round0BCMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageAFieldNumber = 1,
    kCommitmentFieldNumber = 2,
  };
  // string message_a = 1;
  void clear_message_a();
  const std::string& message_a() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message_a(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message_a();
  PROTOBUF_NODISCARD std::string* release_message_a();
  void set_allocated_message_a(std::string* message_a);
  private:
  const std::string& _internal_message_a() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message_a(const std::string& value);
  std::string* _internal_mutable_message_a();
  public:

  // string commitment = 2;
  void clear_commitment();
  const std::string& commitment() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_commitment(ArgT0&& arg0, ArgT... args);
  std::string* mutable_commitment();
  PROTOBUF_NODISCARD std::string* release_commitment();
  void set_allocated_commitment(std::string* commitment);
  private:
  const std::string& _internal_commitment() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_commitment(const std::string& value);
  std::string* _internal_mutable_commitment();
  public:

  // @@protoc_insertion_point(class_scope:safeheron.proto.multi_party_ecdsa.gg18.sign.Round0BCMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_a_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr commitment_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gg18_2fsign_2eproto;
};
// -------------------------------------------------------------------

class Round0P2PMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:safeheron.proto.multi_party_ecdsa.gg18.sign.Round0P2PMessage) */ {
 public:
  inline Round0P2PMessage() : Round0P2PMessage(nullptr) {}
  ~Round0P2PMessage() override;
  explicit PROTOBUF_CONSTEXPR Round0P2PMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Round0P2PMessage(const Round0P2PMessage& from);
  Round0P2PMessage(Round0P2PMessage&& from) noexcept
    : Round0P2PMessage() {
    *this = ::std::move(from);
  }

  inline Round0P2PMessage& operator=(const Round0P2PMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline Round0P2PMessage& operator=(Round0P2PMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Round0P2PMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const Round0P2PMessage* internal_default_instance() {
    return reinterpret_cast<const Round0P2PMessage*>(
               &_Round0P2PMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Round0P2PMessage& a, Round0P2PMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(Round0P2PMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Round0P2PMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Round0P2PMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Round0P2PMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Round0P2PMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Round0P2PMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Round0P2PMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safeheron.proto.multi_party_ecdsa.gg18.sign.Round0P2PMessage";
  }
  protected:
  explicit Round0P2PMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAliceProofFieldNumber = 3,
  };
  // .safeheron.proto.PailEncRangeProof_V1 alice_proof = 3;
  bool has_alice_proof() const;
  private:
  bool _internal_has_alice_proof() const;
  public:
  void clear_alice_proof();
  const ::safeheron::proto::PailEncRangeProof_V1& alice_proof() const;
  PROTOBUF_NODISCARD ::safeheron::proto::PailEncRangeProof_V1* release_alice_proof();
  ::safeheron::proto::PailEncRangeProof_V1* mutable_alice_proof();
  void set_allocated_alice_proof(::safeheron::proto::PailEncRangeProof_V1* alice_proof);
  private:
  const ::safeheron::proto::PailEncRangeProof_V1& _internal_alice_proof() const;
  ::safeheron::proto::PailEncRangeProof_V1* _internal_mutable_alice_proof();
  public:
  void unsafe_arena_set_allocated_alice_proof(
      ::safeheron::proto::PailEncRangeProof_V1* alice_proof);
  ::safeheron::proto::PailEncRangeProof_V1* unsafe_arena_release_alice_proof();

  // @@protoc_insertion_point(class_scope:safeheron.proto.multi_party_ecdsa.gg18.sign.Round0P2PMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::safeheron::proto::PailEncRangeProof_V1* alice_proof_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gg18_2fsign_2eproto;
};
// -------------------------------------------------------------------

class Round1P2PMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:safeheron.proto.multi_party_ecdsa.gg18.sign.Round1P2PMessage) */ {
 public:
  inline Round1P2PMessage() : Round1P2PMessage(nullptr) {}
  ~Round1P2PMessage() override;
  explicit PROTOBUF_CONSTEXPR Round1P2PMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Round1P2PMessage(const Round1P2PMessage& from);
  Round1P2PMessage(Round1P2PMessage&& from) noexcept
    : Round1P2PMessage() {
    *this = ::std::move(from);
  }

  inline Round1P2PMessage& operator=(const Round1P2PMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline Round1P2PMessage& operator=(Round1P2PMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Round1P2PMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const Round1P2PMessage* internal_default_instance() {
    return reinterpret_cast<const Round1P2PMessage*>(
               &_Round1P2PMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Round1P2PMessage& a, Round1P2PMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(Round1P2PMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Round1P2PMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Round1P2PMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Round1P2PMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Round1P2PMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Round1P2PMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Round1P2PMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safeheron.proto.multi_party_ecdsa.gg18.sign.Round1P2PMessage";
  }
  protected:
  explicit Round1P2PMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageBForKGammaFieldNumber = 1,
    kMessageBForKWFieldNumber = 2,
    kBobProof1FieldNumber = 3,
    kBobProof2FieldNumber = 4,
  };
  // string message_b_for_k_gamma = 1;
  void clear_message_b_for_k_gamma();
  const std::string& message_b_for_k_gamma() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message_b_for_k_gamma(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message_b_for_k_gamma();
  PROTOBUF_NODISCARD std::string* release_message_b_for_k_gamma();
  void set_allocated_message_b_for_k_gamma(std::string* message_b_for_k_gamma);
  private:
  const std::string& _internal_message_b_for_k_gamma() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message_b_for_k_gamma(const std::string& value);
  std::string* _internal_mutable_message_b_for_k_gamma();
  public:

  // string message_b_for_k_w = 2;
  void clear_message_b_for_k_w();
  const std::string& message_b_for_k_w() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message_b_for_k_w(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message_b_for_k_w();
  PROTOBUF_NODISCARD std::string* release_message_b_for_k_w();
  void set_allocated_message_b_for_k_w(std::string* message_b_for_k_w);
  private:
  const std::string& _internal_message_b_for_k_w() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message_b_for_k_w(const std::string& value);
  std::string* _internal_mutable_message_b_for_k_w();
  public:

  // .safeheron.proto.PailAffRangeProof bob_proof_1 = 3;
  bool has_bob_proof_1() const;
  private:
  bool _internal_has_bob_proof_1() const;
  public:
  void clear_bob_proof_1();
  const ::safeheron::proto::PailAffRangeProof& bob_proof_1() const;
  PROTOBUF_NODISCARD ::safeheron::proto::PailAffRangeProof* release_bob_proof_1();
  ::safeheron::proto::PailAffRangeProof* mutable_bob_proof_1();
  void set_allocated_bob_proof_1(::safeheron::proto::PailAffRangeProof* bob_proof_1);
  private:
  const ::safeheron::proto::PailAffRangeProof& _internal_bob_proof_1() const;
  ::safeheron::proto::PailAffRangeProof* _internal_mutable_bob_proof_1();
  public:
  void unsafe_arena_set_allocated_bob_proof_1(
      ::safeheron::proto::PailAffRangeProof* bob_proof_1);
  ::safeheron::proto::PailAffRangeProof* unsafe_arena_release_bob_proof_1();

  // .safeheron.proto.PailAffGroupEleRangeProof_V1 bob_proof_2 = 4;
  bool has_bob_proof_2() const;
  private:
  bool _internal_has_bob_proof_2() const;
  public:
  void clear_bob_proof_2();
  const ::safeheron::proto::PailAffGroupEleRangeProof_V1& bob_proof_2() const;
  PROTOBUF_NODISCARD ::safeheron::proto::PailAffGroupEleRangeProof_V1* release_bob_proof_2();
  ::safeheron::proto::PailAffGroupEleRangeProof_V1* mutable_bob_proof_2();
  void set_allocated_bob_proof_2(::safeheron::proto::PailAffGroupEleRangeProof_V1* bob_proof_2);
  private:
  const ::safeheron::proto::PailAffGroupEleRangeProof_V1& _internal_bob_proof_2() const;
  ::safeheron::proto::PailAffGroupEleRangeProof_V1* _internal_mutable_bob_proof_2();
  public:
  void unsafe_arena_set_allocated_bob_proof_2(
      ::safeheron::proto::PailAffGroupEleRangeProof_V1* bob_proof_2);
  ::safeheron::proto::PailAffGroupEleRangeProof_V1* unsafe_arena_release_bob_proof_2();

  // @@protoc_insertion_point(class_scope:safeheron.proto.multi_party_ecdsa.gg18.sign.Round1P2PMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_b_for_k_gamma_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_b_for_k_w_;
  ::safeheron::proto::PailAffRangeProof* bob_proof_1_;
  ::safeheron::proto::PailAffGroupEleRangeProof_V1* bob_proof_2_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gg18_2fsign_2eproto;
};
// -------------------------------------------------------------------

class Round2BCMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:safeheron.proto.multi_party_ecdsa.gg18.sign.Round2BCMessage) */ {
 public:
  inline Round2BCMessage() : Round2BCMessage(nullptr) {}
  ~Round2BCMessage() override;
  explicit PROTOBUF_CONSTEXPR Round2BCMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Round2BCMessage(const Round2BCMessage& from);
  Round2BCMessage(Round2BCMessage&& from) noexcept
    : Round2BCMessage() {
    *this = ::std::move(from);
  }

  inline Round2BCMessage& operator=(const Round2BCMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline Round2BCMessage& operator=(Round2BCMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Round2BCMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const Round2BCMessage* internal_default_instance() {
    return reinterpret_cast<const Round2BCMessage*>(
               &_Round2BCMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Round2BCMessage& a, Round2BCMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(Round2BCMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Round2BCMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Round2BCMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Round2BCMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Round2BCMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Round2BCMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Round2BCMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safeheron.proto.multi_party_ecdsa.gg18.sign.Round2BCMessage";
  }
  protected:
  explicit Round2BCMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeltaFieldNumber = 1,
  };
  // string delta = 1;
  void clear_delta();
  const std::string& delta() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_delta(ArgT0&& arg0, ArgT... args);
  std::string* mutable_delta();
  PROTOBUF_NODISCARD std::string* release_delta();
  void set_allocated_delta(std::string* delta);
  private:
  const std::string& _internal_delta() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_delta(const std::string& value);
  std::string* _internal_mutable_delta();
  public:

  // @@protoc_insertion_point(class_scope:safeheron.proto.multi_party_ecdsa.gg18.sign.Round2BCMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr delta_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gg18_2fsign_2eproto;
};
// -------------------------------------------------------------------

class Round3BCMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:safeheron.proto.multi_party_ecdsa.gg18.sign.Round3BCMessage) */ {
 public:
  inline Round3BCMessage() : Round3BCMessage(nullptr) {}
  ~Round3BCMessage() override;
  explicit PROTOBUF_CONSTEXPR Round3BCMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Round3BCMessage(const Round3BCMessage& from);
  Round3BCMessage(Round3BCMessage&& from) noexcept
    : Round3BCMessage() {
    *this = ::std::move(from);
  }

  inline Round3BCMessage& operator=(const Round3BCMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline Round3BCMessage& operator=(Round3BCMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Round3BCMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const Round3BCMessage* internal_default_instance() {
    return reinterpret_cast<const Round3BCMessage*>(
               &_Round3BCMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Round3BCMessage& a, Round3BCMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(Round3BCMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Round3BCMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Round3BCMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Round3BCMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Round3BCMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Round3BCMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Round3BCMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safeheron.proto.multi_party_ecdsa.gg18.sign.Round3BCMessage";
  }
  protected:
  explicit Round3BCMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlindFactorFieldNumber = 1,
    kDlogProofGammaFieldNumber = 2,
  };
  // string blind_factor = 1;
  void clear_blind_factor();
  const std::string& blind_factor() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_blind_factor(ArgT0&& arg0, ArgT... args);
  std::string* mutable_blind_factor();
  PROTOBUF_NODISCARD std::string* release_blind_factor();
  void set_allocated_blind_factor(std::string* blind_factor);
  private:
  const std::string& _internal_blind_factor() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_blind_factor(const std::string& value);
  std::string* _internal_mutable_blind_factor();
  public:

  // .safeheron.proto.DLogProof dlog_proof_gamma_ = 2;
  bool has_dlog_proof_gamma_() const;
  private:
  bool _internal_has_dlog_proof_gamma_() const;
  public:
  void clear_dlog_proof_gamma_();
  const ::safeheron::proto::DLogProof& dlog_proof_gamma_() const;
  PROTOBUF_NODISCARD ::safeheron::proto::DLogProof* release_dlog_proof_gamma_();
  ::safeheron::proto::DLogProof* mutable_dlog_proof_gamma_();
  void set_allocated_dlog_proof_gamma_(::safeheron::proto::DLogProof* dlog_proof_gamma_);
  private:
  const ::safeheron::proto::DLogProof& _internal_dlog_proof_gamma_() const;
  ::safeheron::proto::DLogProof* _internal_mutable_dlog_proof_gamma_();
  public:
  void unsafe_arena_set_allocated_dlog_proof_gamma_(
      ::safeheron::proto::DLogProof* dlog_proof_gamma_);
  ::safeheron::proto::DLogProof* unsafe_arena_release_dlog_proof_gamma_();

  // @@protoc_insertion_point(class_scope:safeheron.proto.multi_party_ecdsa.gg18.sign.Round3BCMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr blind_factor_;
  ::safeheron::proto::DLogProof* dlog_proof_gamma__;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gg18_2fsign_2eproto;
};
// -------------------------------------------------------------------

class Round4BCMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:safeheron.proto.multi_party_ecdsa.gg18.sign.Round4BCMessage) */ {
 public:
  inline Round4BCMessage() : Round4BCMessage(nullptr) {}
  ~Round4BCMessage() override;
  explicit PROTOBUF_CONSTEXPR Round4BCMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Round4BCMessage(const Round4BCMessage& from);
  Round4BCMessage(Round4BCMessage&& from) noexcept
    : Round4BCMessage() {
    *this = ::std::move(from);
  }

  inline Round4BCMessage& operator=(const Round4BCMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline Round4BCMessage& operator=(Round4BCMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Round4BCMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const Round4BCMessage* internal_default_instance() {
    return reinterpret_cast<const Round4BCMessage*>(
               &_Round4BCMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Round4BCMessage& a, Round4BCMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(Round4BCMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Round4BCMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Round4BCMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Round4BCMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Round4BCMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Round4BCMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Round4BCMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safeheron.proto.multi_party_ecdsa.gg18.sign.Round4BCMessage";
  }
  protected:
  explicit Round4BCMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommitmentFieldNumber = 1,
  };
  // string commitment = 1;
  void clear_commitment();
  const std::string& commitment() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_commitment(ArgT0&& arg0, ArgT... args);
  std::string* mutable_commitment();
  PROTOBUF_NODISCARD std::string* release_commitment();
  void set_allocated_commitment(std::string* commitment);
  private:
  const std::string& _internal_commitment() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_commitment(const std::string& value);
  std::string* _internal_mutable_commitment();
  public:

  // @@protoc_insertion_point(class_scope:safeheron.proto.multi_party_ecdsa.gg18.sign.Round4BCMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr commitment_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gg18_2fsign_2eproto;
};
// -------------------------------------------------------------------

class Round5BCMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:safeheron.proto.multi_party_ecdsa.gg18.sign.Round5BCMessage) */ {
 public:
  inline Round5BCMessage() : Round5BCMessage(nullptr) {}
  ~Round5BCMessage() override;
  explicit PROTOBUF_CONSTEXPR Round5BCMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Round5BCMessage(const Round5BCMessage& from);
  Round5BCMessage(Round5BCMessage&& from) noexcept
    : Round5BCMessage() {
    *this = ::std::move(from);
  }

  inline Round5BCMessage& operator=(const Round5BCMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline Round5BCMessage& operator=(Round5BCMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Round5BCMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const Round5BCMessage* internal_default_instance() {
    return reinterpret_cast<const Round5BCMessage*>(
               &_Round5BCMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Round5BCMessage& a, Round5BCMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(Round5BCMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Round5BCMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Round5BCMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Round5BCMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Round5BCMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Round5BCMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Round5BCMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safeheron.proto.multi_party_ecdsa.gg18.sign.Round5BCMessage";
  }
  protected:
  explicit Round5BCMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlindFactorFieldNumber = 4,
    kVFieldNumber = 1,
    kAFieldNumber = 2,
    kLcProofVRGFieldNumber = 5,
    kDlogProofRhoFieldNumber = 6,
  };
  // string blind_factor = 4;
  void clear_blind_factor();
  const std::string& blind_factor() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_blind_factor(ArgT0&& arg0, ArgT... args);
  std::string* mutable_blind_factor();
  PROTOBUF_NODISCARD std::string* release_blind_factor();
  void set_allocated_blind_factor(std::string* blind_factor);
  private:
  const std::string& _internal_blind_factor() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_blind_factor(const std::string& value);
  std::string* _internal_mutable_blind_factor();
  public:

  // .safeheron.proto.CurvePoint V = 1;
  bool has_v() const;
  private:
  bool _internal_has_v() const;
  public:
  void clear_v();
  const ::safeheron::proto::CurvePoint& v() const;
  PROTOBUF_NODISCARD ::safeheron::proto::CurvePoint* release_v();
  ::safeheron::proto::CurvePoint* mutable_v();
  void set_allocated_v(::safeheron::proto::CurvePoint* v);
  private:
  const ::safeheron::proto::CurvePoint& _internal_v() const;
  ::safeheron::proto::CurvePoint* _internal_mutable_v();
  public:
  void unsafe_arena_set_allocated_v(
      ::safeheron::proto::CurvePoint* v);
  ::safeheron::proto::CurvePoint* unsafe_arena_release_v();

  // .safeheron.proto.CurvePoint A = 2;
  bool has_a() const;
  private:
  bool _internal_has_a() const;
  public:
  void clear_a();
  const ::safeheron::proto::CurvePoint& a() const;
  PROTOBUF_NODISCARD ::safeheron::proto::CurvePoint* release_a();
  ::safeheron::proto::CurvePoint* mutable_a();
  void set_allocated_a(::safeheron::proto::CurvePoint* a);
  private:
  const ::safeheron::proto::CurvePoint& _internal_a() const;
  ::safeheron::proto::CurvePoint* _internal_mutable_a();
  public:
  void unsafe_arena_set_allocated_a(
      ::safeheron::proto::CurvePoint* a);
  ::safeheron::proto::CurvePoint* unsafe_arena_release_a();

  // .safeheron.proto.LinearCombinationProof lc_proof_VRG = 5;
  bool has_lc_proof_vrg() const;
  private:
  bool _internal_has_lc_proof_vrg() const;
  public:
  void clear_lc_proof_vrg();
  const ::safeheron::proto::LinearCombinationProof& lc_proof_vrg() const;
  PROTOBUF_NODISCARD ::safeheron::proto::LinearCombinationProof* release_lc_proof_vrg();
  ::safeheron::proto::LinearCombinationProof* mutable_lc_proof_vrg();
  void set_allocated_lc_proof_vrg(::safeheron::proto::LinearCombinationProof* lc_proof_vrg);
  private:
  const ::safeheron::proto::LinearCombinationProof& _internal_lc_proof_vrg() const;
  ::safeheron::proto::LinearCombinationProof* _internal_mutable_lc_proof_vrg();
  public:
  void unsafe_arena_set_allocated_lc_proof_vrg(
      ::safeheron::proto::LinearCombinationProof* lc_proof_vrg);
  ::safeheron::proto::LinearCombinationProof* unsafe_arena_release_lc_proof_vrg();

  // .safeheron.proto.DLogProof_V2 dlog_proof_rho = 6;
  bool has_dlog_proof_rho() const;
  private:
  bool _internal_has_dlog_proof_rho() const;
  public:
  void clear_dlog_proof_rho();
  const ::safeheron::proto::DLogProof_V2& dlog_proof_rho() const;
  PROTOBUF_NODISCARD ::safeheron::proto::DLogProof_V2* release_dlog_proof_rho();
  ::safeheron::proto::DLogProof_V2* mutable_dlog_proof_rho();
  void set_allocated_dlog_proof_rho(::safeheron::proto::DLogProof_V2* dlog_proof_rho);
  private:
  const ::safeheron::proto::DLogProof_V2& _internal_dlog_proof_rho() const;
  ::safeheron::proto::DLogProof_V2* _internal_mutable_dlog_proof_rho();
  public:
  void unsafe_arena_set_allocated_dlog_proof_rho(
      ::safeheron::proto::DLogProof_V2* dlog_proof_rho);
  ::safeheron::proto::DLogProof_V2* unsafe_arena_release_dlog_proof_rho();

  // @@protoc_insertion_point(class_scope:safeheron.proto.multi_party_ecdsa.gg18.sign.Round5BCMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr blind_factor_;
  ::safeheron::proto::CurvePoint* v_;
  ::safeheron::proto::CurvePoint* a_;
  ::safeheron::proto::LinearCombinationProof* lc_proof_vrg_;
  ::safeheron::proto::DLogProof_V2* dlog_proof_rho_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gg18_2fsign_2eproto;
};
// -------------------------------------------------------------------

class Round6BCMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:safeheron.proto.multi_party_ecdsa.gg18.sign.Round6BCMessage) */ {
 public:
  inline Round6BCMessage() : Round6BCMessage(nullptr) {}
  ~Round6BCMessage() override;
  explicit PROTOBUF_CONSTEXPR Round6BCMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Round6BCMessage(const Round6BCMessage& from);
  Round6BCMessage(Round6BCMessage&& from) noexcept
    : Round6BCMessage() {
    *this = ::std::move(from);
  }

  inline Round6BCMessage& operator=(const Round6BCMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline Round6BCMessage& operator=(Round6BCMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Round6BCMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const Round6BCMessage* internal_default_instance() {
    return reinterpret_cast<const Round6BCMessage*>(
               &_Round6BCMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Round6BCMessage& a, Round6BCMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(Round6BCMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Round6BCMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Round6BCMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Round6BCMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Round6BCMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Round6BCMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Round6BCMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safeheron.proto.multi_party_ecdsa.gg18.sign.Round6BCMessage";
  }
  protected:
  explicit Round6BCMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCommitmentFieldNumber = 1,
  };
  // string commitment = 1;
  void clear_commitment();
  const std::string& commitment() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_commitment(ArgT0&& arg0, ArgT... args);
  std::string* mutable_commitment();
  PROTOBUF_NODISCARD std::string* release_commitment();
  void set_allocated_commitment(std::string* commitment);
  private:
  const std::string& _internal_commitment() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_commitment(const std::string& value);
  std::string* _internal_mutable_commitment();
  public:

  // @@protoc_insertion_point(class_scope:safeheron.proto.multi_party_ecdsa.gg18.sign.Round6BCMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr commitment_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gg18_2fsign_2eproto;
};
// -------------------------------------------------------------------

class Round7BCMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:safeheron.proto.multi_party_ecdsa.gg18.sign.Round7BCMessage) */ {
 public:
  inline Round7BCMessage() : Round7BCMessage(nullptr) {}
  ~Round7BCMessage() override;
  explicit PROTOBUF_CONSTEXPR Round7BCMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Round7BCMessage(const Round7BCMessage& from);
  Round7BCMessage(Round7BCMessage&& from) noexcept
    : Round7BCMessage() {
    *this = ::std::move(from);
  }

  inline Round7BCMessage& operator=(const Round7BCMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline Round7BCMessage& operator=(Round7BCMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Round7BCMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const Round7BCMessage* internal_default_instance() {
    return reinterpret_cast<const Round7BCMessage*>(
               &_Round7BCMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Round7BCMessage& a, Round7BCMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(Round7BCMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Round7BCMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Round7BCMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Round7BCMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Round7BCMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Round7BCMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Round7BCMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safeheron.proto.multi_party_ecdsa.gg18.sign.Round7BCMessage";
  }
  protected:
  explicit Round7BCMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlindFactorFieldNumber = 3,
    kUFieldNumber = 1,
    kTFieldNumber = 2,
  };
  // string blind_factor = 3;
  void clear_blind_factor();
  const std::string& blind_factor() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_blind_factor(ArgT0&& arg0, ArgT... args);
  std::string* mutable_blind_factor();
  PROTOBUF_NODISCARD std::string* release_blind_factor();
  void set_allocated_blind_factor(std::string* blind_factor);
  private:
  const std::string& _internal_blind_factor() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_blind_factor(const std::string& value);
  std::string* _internal_mutable_blind_factor();
  public:

  // .safeheron.proto.CurvePoint U = 1;
  bool has_u() const;
  private:
  bool _internal_has_u() const;
  public:
  void clear_u();
  const ::safeheron::proto::CurvePoint& u() const;
  PROTOBUF_NODISCARD ::safeheron::proto::CurvePoint* release_u();
  ::safeheron::proto::CurvePoint* mutable_u();
  void set_allocated_u(::safeheron::proto::CurvePoint* u);
  private:
  const ::safeheron::proto::CurvePoint& _internal_u() const;
  ::safeheron::proto::CurvePoint* _internal_mutable_u();
  public:
  void unsafe_arena_set_allocated_u(
      ::safeheron::proto::CurvePoint* u);
  ::safeheron::proto::CurvePoint* unsafe_arena_release_u();

  // .safeheron.proto.CurvePoint T = 2;
  bool has_t() const;
  private:
  bool _internal_has_t() const;
  public:
  void clear_t();
  const ::safeheron::proto::CurvePoint& t() const;
  PROTOBUF_NODISCARD ::safeheron::proto::CurvePoint* release_t();
  ::safeheron::proto::CurvePoint* mutable_t();
  void set_allocated_t(::safeheron::proto::CurvePoint* t);
  private:
  const ::safeheron::proto::CurvePoint& _internal_t() const;
  ::safeheron::proto::CurvePoint* _internal_mutable_t();
  public:
  void unsafe_arena_set_allocated_t(
      ::safeheron::proto::CurvePoint* t);
  ::safeheron::proto::CurvePoint* unsafe_arena_release_t();

  // @@protoc_insertion_point(class_scope:safeheron.proto.multi_party_ecdsa.gg18.sign.Round7BCMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr blind_factor_;
  ::safeheron::proto::CurvePoint* u_;
  ::safeheron::proto::CurvePoint* t_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gg18_2fsign_2eproto;
};
// -------------------------------------------------------------------

class Round8BCMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:safeheron.proto.multi_party_ecdsa.gg18.sign.Round8BCMessage) */ {
 public:
  inline Round8BCMessage() : Round8BCMessage(nullptr) {}
  ~Round8BCMessage() override;
  explicit PROTOBUF_CONSTEXPR Round8BCMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Round8BCMessage(const Round8BCMessage& from);
  Round8BCMessage(Round8BCMessage&& from) noexcept
    : Round8BCMessage() {
    *this = ::std::move(from);
  }

  inline Round8BCMessage& operator=(const Round8BCMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline Round8BCMessage& operator=(Round8BCMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Round8BCMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const Round8BCMessage* internal_default_instance() {
    return reinterpret_cast<const Round8BCMessage*>(
               &_Round8BCMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Round8BCMessage& a, Round8BCMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(Round8BCMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Round8BCMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Round8BCMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Round8BCMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Round8BCMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Round8BCMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Round8BCMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "safeheron.proto.multi_party_ecdsa.gg18.sign.Round8BCMessage";
  }
  protected:
  explicit Round8BCMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSiFieldNumber = 1,
  };
  // string si = 1;
  void clear_si();
  const std::string& si() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_si(ArgT0&& arg0, ArgT... args);
  std::string* mutable_si();
  PROTOBUF_NODISCARD std::string* release_si();
  void set_allocated_si(std::string* si);
  private:
  const std::string& _internal_si() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_si(const std::string& value);
  std::string* _internal_mutable_si();
  public:

  // @@protoc_insertion_point(class_scope:safeheron.proto.multi_party_ecdsa.gg18.sign.Round8BCMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr si_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_gg18_2fsign_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Round0BCMessage

// string message_a = 1;
inline void Round0BCMessage::clear_message_a() {
  message_a_.ClearToEmpty();
}
inline const std::string& Round0BCMessage::message_a() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.multi_party_ecdsa.gg18.sign.Round0BCMessage.message_a)
  return _internal_message_a();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Round0BCMessage::set_message_a(ArgT0&& arg0, ArgT... args) {
 
 message_a_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.multi_party_ecdsa.gg18.sign.Round0BCMessage.message_a)
}
inline std::string* Round0BCMessage::mutable_message_a() {
  std::string* _s = _internal_mutable_message_a();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.multi_party_ecdsa.gg18.sign.Round0BCMessage.message_a)
  return _s;
}
inline const std::string& Round0BCMessage::_internal_message_a() const {
  return message_a_.Get();
}
inline void Round0BCMessage::_internal_set_message_a(const std::string& value) {
  
  message_a_.Set(value, GetArenaForAllocation());
}
inline std::string* Round0BCMessage::_internal_mutable_message_a() {
  
  return message_a_.Mutable(GetArenaForAllocation());
}
inline std::string* Round0BCMessage::release_message_a() {
  // @@protoc_insertion_point(field_release:safeheron.proto.multi_party_ecdsa.gg18.sign.Round0BCMessage.message_a)
  return message_a_.Release();
}
inline void Round0BCMessage::set_allocated_message_a(std::string* message_a) {
  if (message_a != nullptr) {
    
  } else {
    
  }
  message_a_.SetAllocated(message_a, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (message_a_.IsDefault()) {
    message_a_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.multi_party_ecdsa.gg18.sign.Round0BCMessage.message_a)
}

// string commitment = 2;
inline void Round0BCMessage::clear_commitment() {
  commitment_.ClearToEmpty();
}
inline const std::string& Round0BCMessage::commitment() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.multi_party_ecdsa.gg18.sign.Round0BCMessage.commitment)
  return _internal_commitment();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Round0BCMessage::set_commitment(ArgT0&& arg0, ArgT... args) {
 
 commitment_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.multi_party_ecdsa.gg18.sign.Round0BCMessage.commitment)
}
inline std::string* Round0BCMessage::mutable_commitment() {
  std::string* _s = _internal_mutable_commitment();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.multi_party_ecdsa.gg18.sign.Round0BCMessage.commitment)
  return _s;
}
inline const std::string& Round0BCMessage::_internal_commitment() const {
  return commitment_.Get();
}
inline void Round0BCMessage::_internal_set_commitment(const std::string& value) {
  
  commitment_.Set(value, GetArenaForAllocation());
}
inline std::string* Round0BCMessage::_internal_mutable_commitment() {
  
  return commitment_.Mutable(GetArenaForAllocation());
}
inline std::string* Round0BCMessage::release_commitment() {
  // @@protoc_insertion_point(field_release:safeheron.proto.multi_party_ecdsa.gg18.sign.Round0BCMessage.commitment)
  return commitment_.Release();
}
inline void Round0BCMessage::set_allocated_commitment(std::string* commitment) {
  if (commitment != nullptr) {
    
  } else {
    
  }
  commitment_.SetAllocated(commitment, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (commitment_.IsDefault()) {
    commitment_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.multi_party_ecdsa.gg18.sign.Round0BCMessage.commitment)
}

// -------------------------------------------------------------------

// Round0P2PMessage

// .safeheron.proto.PailEncRangeProof_V1 alice_proof = 3;
inline bool Round0P2PMessage::_internal_has_alice_proof() const {
  return this != internal_default_instance() && alice_proof_ != nullptr;
}
inline bool Round0P2PMessage::has_alice_proof() const {
  return _internal_has_alice_proof();
}
inline const ::safeheron::proto::PailEncRangeProof_V1& Round0P2PMessage::_internal_alice_proof() const {
  const ::safeheron::proto::PailEncRangeProof_V1* p = alice_proof_;
  return p != nullptr ? *p : reinterpret_cast<const ::safeheron::proto::PailEncRangeProof_V1&>(
      ::safeheron::proto::_PailEncRangeProof_V1_default_instance_);
}
inline const ::safeheron::proto::PailEncRangeProof_V1& Round0P2PMessage::alice_proof() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.multi_party_ecdsa.gg18.sign.Round0P2PMessage.alice_proof)
  return _internal_alice_proof();
}
inline void Round0P2PMessage::unsafe_arena_set_allocated_alice_proof(
    ::safeheron::proto::PailEncRangeProof_V1* alice_proof) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(alice_proof_);
  }
  alice_proof_ = alice_proof;
  if (alice_proof) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:safeheron.proto.multi_party_ecdsa.gg18.sign.Round0P2PMessage.alice_proof)
}
inline ::safeheron::proto::PailEncRangeProof_V1* Round0P2PMessage::release_alice_proof() {
  
  ::safeheron::proto::PailEncRangeProof_V1* temp = alice_proof_;
  alice_proof_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::safeheron::proto::PailEncRangeProof_V1* Round0P2PMessage::unsafe_arena_release_alice_proof() {
  // @@protoc_insertion_point(field_release:safeheron.proto.multi_party_ecdsa.gg18.sign.Round0P2PMessage.alice_proof)
  
  ::safeheron::proto::PailEncRangeProof_V1* temp = alice_proof_;
  alice_proof_ = nullptr;
  return temp;
}
inline ::safeheron::proto::PailEncRangeProof_V1* Round0P2PMessage::_internal_mutable_alice_proof() {
  
  if (alice_proof_ == nullptr) {
    auto* p = CreateMaybeMessage<::safeheron::proto::PailEncRangeProof_V1>(GetArenaForAllocation());
    alice_proof_ = p;
  }
  return alice_proof_;
}
inline ::safeheron::proto::PailEncRangeProof_V1* Round0P2PMessage::mutable_alice_proof() {
  ::safeheron::proto::PailEncRangeProof_V1* _msg = _internal_mutable_alice_proof();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.multi_party_ecdsa.gg18.sign.Round0P2PMessage.alice_proof)
  return _msg;
}
inline void Round0P2PMessage::set_allocated_alice_proof(::safeheron::proto::PailEncRangeProof_V1* alice_proof) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(alice_proof_);
  }
  if (alice_proof) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(alice_proof));
    if (message_arena != submessage_arena) {
      alice_proof = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, alice_proof, submessage_arena);
    }
    
  } else {
    
  }
  alice_proof_ = alice_proof;
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.multi_party_ecdsa.gg18.sign.Round0P2PMessage.alice_proof)
}

// -------------------------------------------------------------------

// Round1P2PMessage

// string message_b_for_k_gamma = 1;
inline void Round1P2PMessage::clear_message_b_for_k_gamma() {
  message_b_for_k_gamma_.ClearToEmpty();
}
inline const std::string& Round1P2PMessage::message_b_for_k_gamma() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.multi_party_ecdsa.gg18.sign.Round1P2PMessage.message_b_for_k_gamma)
  return _internal_message_b_for_k_gamma();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Round1P2PMessage::set_message_b_for_k_gamma(ArgT0&& arg0, ArgT... args) {
 
 message_b_for_k_gamma_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.multi_party_ecdsa.gg18.sign.Round1P2PMessage.message_b_for_k_gamma)
}
inline std::string* Round1P2PMessage::mutable_message_b_for_k_gamma() {
  std::string* _s = _internal_mutable_message_b_for_k_gamma();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.multi_party_ecdsa.gg18.sign.Round1P2PMessage.message_b_for_k_gamma)
  return _s;
}
inline const std::string& Round1P2PMessage::_internal_message_b_for_k_gamma() const {
  return message_b_for_k_gamma_.Get();
}
inline void Round1P2PMessage::_internal_set_message_b_for_k_gamma(const std::string& value) {
  
  message_b_for_k_gamma_.Set(value, GetArenaForAllocation());
}
inline std::string* Round1P2PMessage::_internal_mutable_message_b_for_k_gamma() {
  
  return message_b_for_k_gamma_.Mutable(GetArenaForAllocation());
}
inline std::string* Round1P2PMessage::release_message_b_for_k_gamma() {
  // @@protoc_insertion_point(field_release:safeheron.proto.multi_party_ecdsa.gg18.sign.Round1P2PMessage.message_b_for_k_gamma)
  return message_b_for_k_gamma_.Release();
}
inline void Round1P2PMessage::set_allocated_message_b_for_k_gamma(std::string* message_b_for_k_gamma) {
  if (message_b_for_k_gamma != nullptr) {
    
  } else {
    
  }
  message_b_for_k_gamma_.SetAllocated(message_b_for_k_gamma, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (message_b_for_k_gamma_.IsDefault()) {
    message_b_for_k_gamma_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.multi_party_ecdsa.gg18.sign.Round1P2PMessage.message_b_for_k_gamma)
}

// string message_b_for_k_w = 2;
inline void Round1P2PMessage::clear_message_b_for_k_w() {
  message_b_for_k_w_.ClearToEmpty();
}
inline const std::string& Round1P2PMessage::message_b_for_k_w() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.multi_party_ecdsa.gg18.sign.Round1P2PMessage.message_b_for_k_w)
  return _internal_message_b_for_k_w();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Round1P2PMessage::set_message_b_for_k_w(ArgT0&& arg0, ArgT... args) {
 
 message_b_for_k_w_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.multi_party_ecdsa.gg18.sign.Round1P2PMessage.message_b_for_k_w)
}
inline std::string* Round1P2PMessage::mutable_message_b_for_k_w() {
  std::string* _s = _internal_mutable_message_b_for_k_w();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.multi_party_ecdsa.gg18.sign.Round1P2PMessage.message_b_for_k_w)
  return _s;
}
inline const std::string& Round1P2PMessage::_internal_message_b_for_k_w() const {
  return message_b_for_k_w_.Get();
}
inline void Round1P2PMessage::_internal_set_message_b_for_k_w(const std::string& value) {
  
  message_b_for_k_w_.Set(value, GetArenaForAllocation());
}
inline std::string* Round1P2PMessage::_internal_mutable_message_b_for_k_w() {
  
  return message_b_for_k_w_.Mutable(GetArenaForAllocation());
}
inline std::string* Round1P2PMessage::release_message_b_for_k_w() {
  // @@protoc_insertion_point(field_release:safeheron.proto.multi_party_ecdsa.gg18.sign.Round1P2PMessage.message_b_for_k_w)
  return message_b_for_k_w_.Release();
}
inline void Round1P2PMessage::set_allocated_message_b_for_k_w(std::string* message_b_for_k_w) {
  if (message_b_for_k_w != nullptr) {
    
  } else {
    
  }
  message_b_for_k_w_.SetAllocated(message_b_for_k_w, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (message_b_for_k_w_.IsDefault()) {
    message_b_for_k_w_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.multi_party_ecdsa.gg18.sign.Round1P2PMessage.message_b_for_k_w)
}

// .safeheron.proto.PailAffRangeProof bob_proof_1 = 3;
inline bool Round1P2PMessage::_internal_has_bob_proof_1() const {
  return this != internal_default_instance() && bob_proof_1_ != nullptr;
}
inline bool Round1P2PMessage::has_bob_proof_1() const {
  return _internal_has_bob_proof_1();
}
inline const ::safeheron::proto::PailAffRangeProof& Round1P2PMessage::_internal_bob_proof_1() const {
  const ::safeheron::proto::PailAffRangeProof* p = bob_proof_1_;
  return p != nullptr ? *p : reinterpret_cast<const ::safeheron::proto::PailAffRangeProof&>(
      ::safeheron::proto::_PailAffRangeProof_default_instance_);
}
inline const ::safeheron::proto::PailAffRangeProof& Round1P2PMessage::bob_proof_1() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.multi_party_ecdsa.gg18.sign.Round1P2PMessage.bob_proof_1)
  return _internal_bob_proof_1();
}
inline void Round1P2PMessage::unsafe_arena_set_allocated_bob_proof_1(
    ::safeheron::proto::PailAffRangeProof* bob_proof_1) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bob_proof_1_);
  }
  bob_proof_1_ = bob_proof_1;
  if (bob_proof_1) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:safeheron.proto.multi_party_ecdsa.gg18.sign.Round1P2PMessage.bob_proof_1)
}
inline ::safeheron::proto::PailAffRangeProof* Round1P2PMessage::release_bob_proof_1() {
  
  ::safeheron::proto::PailAffRangeProof* temp = bob_proof_1_;
  bob_proof_1_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::safeheron::proto::PailAffRangeProof* Round1P2PMessage::unsafe_arena_release_bob_proof_1() {
  // @@protoc_insertion_point(field_release:safeheron.proto.multi_party_ecdsa.gg18.sign.Round1P2PMessage.bob_proof_1)
  
  ::safeheron::proto::PailAffRangeProof* temp = bob_proof_1_;
  bob_proof_1_ = nullptr;
  return temp;
}
inline ::safeheron::proto::PailAffRangeProof* Round1P2PMessage::_internal_mutable_bob_proof_1() {
  
  if (bob_proof_1_ == nullptr) {
    auto* p = CreateMaybeMessage<::safeheron::proto::PailAffRangeProof>(GetArenaForAllocation());
    bob_proof_1_ = p;
  }
  return bob_proof_1_;
}
inline ::safeheron::proto::PailAffRangeProof* Round1P2PMessage::mutable_bob_proof_1() {
  ::safeheron::proto::PailAffRangeProof* _msg = _internal_mutable_bob_proof_1();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.multi_party_ecdsa.gg18.sign.Round1P2PMessage.bob_proof_1)
  return _msg;
}
inline void Round1P2PMessage::set_allocated_bob_proof_1(::safeheron::proto::PailAffRangeProof* bob_proof_1) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(bob_proof_1_);
  }
  if (bob_proof_1) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bob_proof_1));
    if (message_arena != submessage_arena) {
      bob_proof_1 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bob_proof_1, submessage_arena);
    }
    
  } else {
    
  }
  bob_proof_1_ = bob_proof_1;
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.multi_party_ecdsa.gg18.sign.Round1P2PMessage.bob_proof_1)
}

// .safeheron.proto.PailAffGroupEleRangeProof_V1 bob_proof_2 = 4;
inline bool Round1P2PMessage::_internal_has_bob_proof_2() const {
  return this != internal_default_instance() && bob_proof_2_ != nullptr;
}
inline bool Round1P2PMessage::has_bob_proof_2() const {
  return _internal_has_bob_proof_2();
}
inline const ::safeheron::proto::PailAffGroupEleRangeProof_V1& Round1P2PMessage::_internal_bob_proof_2() const {
  const ::safeheron::proto::PailAffGroupEleRangeProof_V1* p = bob_proof_2_;
  return p != nullptr ? *p : reinterpret_cast<const ::safeheron::proto::PailAffGroupEleRangeProof_V1&>(
      ::safeheron::proto::_PailAffGroupEleRangeProof_V1_default_instance_);
}
inline const ::safeheron::proto::PailAffGroupEleRangeProof_V1& Round1P2PMessage::bob_proof_2() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.multi_party_ecdsa.gg18.sign.Round1P2PMessage.bob_proof_2)
  return _internal_bob_proof_2();
}
inline void Round1P2PMessage::unsafe_arena_set_allocated_bob_proof_2(
    ::safeheron::proto::PailAffGroupEleRangeProof_V1* bob_proof_2) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bob_proof_2_);
  }
  bob_proof_2_ = bob_proof_2;
  if (bob_proof_2) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:safeheron.proto.multi_party_ecdsa.gg18.sign.Round1P2PMessage.bob_proof_2)
}
inline ::safeheron::proto::PailAffGroupEleRangeProof_V1* Round1P2PMessage::release_bob_proof_2() {
  
  ::safeheron::proto::PailAffGroupEleRangeProof_V1* temp = bob_proof_2_;
  bob_proof_2_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::safeheron::proto::PailAffGroupEleRangeProof_V1* Round1P2PMessage::unsafe_arena_release_bob_proof_2() {
  // @@protoc_insertion_point(field_release:safeheron.proto.multi_party_ecdsa.gg18.sign.Round1P2PMessage.bob_proof_2)
  
  ::safeheron::proto::PailAffGroupEleRangeProof_V1* temp = bob_proof_2_;
  bob_proof_2_ = nullptr;
  return temp;
}
inline ::safeheron::proto::PailAffGroupEleRangeProof_V1* Round1P2PMessage::_internal_mutable_bob_proof_2() {
  
  if (bob_proof_2_ == nullptr) {
    auto* p = CreateMaybeMessage<::safeheron::proto::PailAffGroupEleRangeProof_V1>(GetArenaForAllocation());
    bob_proof_2_ = p;
  }
  return bob_proof_2_;
}
inline ::safeheron::proto::PailAffGroupEleRangeProof_V1* Round1P2PMessage::mutable_bob_proof_2() {
  ::safeheron::proto::PailAffGroupEleRangeProof_V1* _msg = _internal_mutable_bob_proof_2();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.multi_party_ecdsa.gg18.sign.Round1P2PMessage.bob_proof_2)
  return _msg;
}
inline void Round1P2PMessage::set_allocated_bob_proof_2(::safeheron::proto::PailAffGroupEleRangeProof_V1* bob_proof_2) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(bob_proof_2_);
  }
  if (bob_proof_2) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bob_proof_2));
    if (message_arena != submessage_arena) {
      bob_proof_2 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bob_proof_2, submessage_arena);
    }
    
  } else {
    
  }
  bob_proof_2_ = bob_proof_2;
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.multi_party_ecdsa.gg18.sign.Round1P2PMessage.bob_proof_2)
}

// -------------------------------------------------------------------

// Round2BCMessage

// string delta = 1;
inline void Round2BCMessage::clear_delta() {
  delta_.ClearToEmpty();
}
inline const std::string& Round2BCMessage::delta() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.multi_party_ecdsa.gg18.sign.Round2BCMessage.delta)
  return _internal_delta();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Round2BCMessage::set_delta(ArgT0&& arg0, ArgT... args) {
 
 delta_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.multi_party_ecdsa.gg18.sign.Round2BCMessage.delta)
}
inline std::string* Round2BCMessage::mutable_delta() {
  std::string* _s = _internal_mutable_delta();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.multi_party_ecdsa.gg18.sign.Round2BCMessage.delta)
  return _s;
}
inline const std::string& Round2BCMessage::_internal_delta() const {
  return delta_.Get();
}
inline void Round2BCMessage::_internal_set_delta(const std::string& value) {
  
  delta_.Set(value, GetArenaForAllocation());
}
inline std::string* Round2BCMessage::_internal_mutable_delta() {
  
  return delta_.Mutable(GetArenaForAllocation());
}
inline std::string* Round2BCMessage::release_delta() {
  // @@protoc_insertion_point(field_release:safeheron.proto.multi_party_ecdsa.gg18.sign.Round2BCMessage.delta)
  return delta_.Release();
}
inline void Round2BCMessage::set_allocated_delta(std::string* delta) {
  if (delta != nullptr) {
    
  } else {
    
  }
  delta_.SetAllocated(delta, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (delta_.IsDefault()) {
    delta_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.multi_party_ecdsa.gg18.sign.Round2BCMessage.delta)
}

// -------------------------------------------------------------------

// Round3BCMessage

// string blind_factor = 1;
inline void Round3BCMessage::clear_blind_factor() {
  blind_factor_.ClearToEmpty();
}
inline const std::string& Round3BCMessage::blind_factor() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.multi_party_ecdsa.gg18.sign.Round3BCMessage.blind_factor)
  return _internal_blind_factor();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Round3BCMessage::set_blind_factor(ArgT0&& arg0, ArgT... args) {
 
 blind_factor_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.multi_party_ecdsa.gg18.sign.Round3BCMessage.blind_factor)
}
inline std::string* Round3BCMessage::mutable_blind_factor() {
  std::string* _s = _internal_mutable_blind_factor();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.multi_party_ecdsa.gg18.sign.Round3BCMessage.blind_factor)
  return _s;
}
inline const std::string& Round3BCMessage::_internal_blind_factor() const {
  return blind_factor_.Get();
}
inline void Round3BCMessage::_internal_set_blind_factor(const std::string& value) {
  
  blind_factor_.Set(value, GetArenaForAllocation());
}
inline std::string* Round3BCMessage::_internal_mutable_blind_factor() {
  
  return blind_factor_.Mutable(GetArenaForAllocation());
}
inline std::string* Round3BCMessage::release_blind_factor() {
  // @@protoc_insertion_point(field_release:safeheron.proto.multi_party_ecdsa.gg18.sign.Round3BCMessage.blind_factor)
  return blind_factor_.Release();
}
inline void Round3BCMessage::set_allocated_blind_factor(std::string* blind_factor) {
  if (blind_factor != nullptr) {
    
  } else {
    
  }
  blind_factor_.SetAllocated(blind_factor, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (blind_factor_.IsDefault()) {
    blind_factor_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.multi_party_ecdsa.gg18.sign.Round3BCMessage.blind_factor)
}

// .safeheron.proto.DLogProof dlog_proof_gamma_ = 2;
inline bool Round3BCMessage::_internal_has_dlog_proof_gamma_() const {
  return this != internal_default_instance() && dlog_proof_gamma__ != nullptr;
}
inline bool Round3BCMessage::has_dlog_proof_gamma_() const {
  return _internal_has_dlog_proof_gamma_();
}
inline const ::safeheron::proto::DLogProof& Round3BCMessage::_internal_dlog_proof_gamma_() const {
  const ::safeheron::proto::DLogProof* p = dlog_proof_gamma__;
  return p != nullptr ? *p : reinterpret_cast<const ::safeheron::proto::DLogProof&>(
      ::safeheron::proto::_DLogProof_default_instance_);
}
inline const ::safeheron::proto::DLogProof& Round3BCMessage::dlog_proof_gamma_() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.multi_party_ecdsa.gg18.sign.Round3BCMessage.dlog_proof_gamma_)
  return _internal_dlog_proof_gamma_();
}
inline void Round3BCMessage::unsafe_arena_set_allocated_dlog_proof_gamma_(
    ::safeheron::proto::DLogProof* dlog_proof_gamma_) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dlog_proof_gamma__);
  }
  dlog_proof_gamma__ = dlog_proof_gamma_;
  if (dlog_proof_gamma_) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:safeheron.proto.multi_party_ecdsa.gg18.sign.Round3BCMessage.dlog_proof_gamma_)
}
inline ::safeheron::proto::DLogProof* Round3BCMessage::release_dlog_proof_gamma_() {
  
  ::safeheron::proto::DLogProof* temp = dlog_proof_gamma__;
  dlog_proof_gamma__ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::safeheron::proto::DLogProof* Round3BCMessage::unsafe_arena_release_dlog_proof_gamma_() {
  // @@protoc_insertion_point(field_release:safeheron.proto.multi_party_ecdsa.gg18.sign.Round3BCMessage.dlog_proof_gamma_)
  
  ::safeheron::proto::DLogProof* temp = dlog_proof_gamma__;
  dlog_proof_gamma__ = nullptr;
  return temp;
}
inline ::safeheron::proto::DLogProof* Round3BCMessage::_internal_mutable_dlog_proof_gamma_() {
  
  if (dlog_proof_gamma__ == nullptr) {
    auto* p = CreateMaybeMessage<::safeheron::proto::DLogProof>(GetArenaForAllocation());
    dlog_proof_gamma__ = p;
  }
  return dlog_proof_gamma__;
}
inline ::safeheron::proto::DLogProof* Round3BCMessage::mutable_dlog_proof_gamma_() {
  ::safeheron::proto::DLogProof* _msg = _internal_mutable_dlog_proof_gamma_();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.multi_party_ecdsa.gg18.sign.Round3BCMessage.dlog_proof_gamma_)
  return _msg;
}
inline void Round3BCMessage::set_allocated_dlog_proof_gamma_(::safeheron::proto::DLogProof* dlog_proof_gamma_) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(dlog_proof_gamma__);
  }
  if (dlog_proof_gamma_) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dlog_proof_gamma_));
    if (message_arena != submessage_arena) {
      dlog_proof_gamma_ = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dlog_proof_gamma_, submessage_arena);
    }
    
  } else {
    
  }
  dlog_proof_gamma__ = dlog_proof_gamma_;
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.multi_party_ecdsa.gg18.sign.Round3BCMessage.dlog_proof_gamma_)
}

// -------------------------------------------------------------------

// Round4BCMessage

// string commitment = 1;
inline void Round4BCMessage::clear_commitment() {
  commitment_.ClearToEmpty();
}
inline const std::string& Round4BCMessage::commitment() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.multi_party_ecdsa.gg18.sign.Round4BCMessage.commitment)
  return _internal_commitment();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Round4BCMessage::set_commitment(ArgT0&& arg0, ArgT... args) {
 
 commitment_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.multi_party_ecdsa.gg18.sign.Round4BCMessage.commitment)
}
inline std::string* Round4BCMessage::mutable_commitment() {
  std::string* _s = _internal_mutable_commitment();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.multi_party_ecdsa.gg18.sign.Round4BCMessage.commitment)
  return _s;
}
inline const std::string& Round4BCMessage::_internal_commitment() const {
  return commitment_.Get();
}
inline void Round4BCMessage::_internal_set_commitment(const std::string& value) {
  
  commitment_.Set(value, GetArenaForAllocation());
}
inline std::string* Round4BCMessage::_internal_mutable_commitment() {
  
  return commitment_.Mutable(GetArenaForAllocation());
}
inline std::string* Round4BCMessage::release_commitment() {
  // @@protoc_insertion_point(field_release:safeheron.proto.multi_party_ecdsa.gg18.sign.Round4BCMessage.commitment)
  return commitment_.Release();
}
inline void Round4BCMessage::set_allocated_commitment(std::string* commitment) {
  if (commitment != nullptr) {
    
  } else {
    
  }
  commitment_.SetAllocated(commitment, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (commitment_.IsDefault()) {
    commitment_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.multi_party_ecdsa.gg18.sign.Round4BCMessage.commitment)
}

// -------------------------------------------------------------------

// Round5BCMessage

// .safeheron.proto.CurvePoint V = 1;
inline bool Round5BCMessage::_internal_has_v() const {
  return this != internal_default_instance() && v_ != nullptr;
}
inline bool Round5BCMessage::has_v() const {
  return _internal_has_v();
}
inline const ::safeheron::proto::CurvePoint& Round5BCMessage::_internal_v() const {
  const ::safeheron::proto::CurvePoint* p = v_;
  return p != nullptr ? *p : reinterpret_cast<const ::safeheron::proto::CurvePoint&>(
      ::safeheron::proto::_CurvePoint_default_instance_);
}
inline const ::safeheron::proto::CurvePoint& Round5BCMessage::v() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.multi_party_ecdsa.gg18.sign.Round5BCMessage.V)
  return _internal_v();
}
inline void Round5BCMessage::unsafe_arena_set_allocated_v(
    ::safeheron::proto::CurvePoint* v) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(v_);
  }
  v_ = v;
  if (v) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:safeheron.proto.multi_party_ecdsa.gg18.sign.Round5BCMessage.V)
}
inline ::safeheron::proto::CurvePoint* Round5BCMessage::release_v() {
  
  ::safeheron::proto::CurvePoint* temp = v_;
  v_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::safeheron::proto::CurvePoint* Round5BCMessage::unsafe_arena_release_v() {
  // @@protoc_insertion_point(field_release:safeheron.proto.multi_party_ecdsa.gg18.sign.Round5BCMessage.V)
  
  ::safeheron::proto::CurvePoint* temp = v_;
  v_ = nullptr;
  return temp;
}
inline ::safeheron::proto::CurvePoint* Round5BCMessage::_internal_mutable_v() {
  
  if (v_ == nullptr) {
    auto* p = CreateMaybeMessage<::safeheron::proto::CurvePoint>(GetArenaForAllocation());
    v_ = p;
  }
  return v_;
}
inline ::safeheron::proto::CurvePoint* Round5BCMessage::mutable_v() {
  ::safeheron::proto::CurvePoint* _msg = _internal_mutable_v();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.multi_party_ecdsa.gg18.sign.Round5BCMessage.V)
  return _msg;
}
inline void Round5BCMessage::set_allocated_v(::safeheron::proto::CurvePoint* v) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(v_);
  }
  if (v) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(v));
    if (message_arena != submessage_arena) {
      v = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, v, submessage_arena);
    }
    
  } else {
    
  }
  v_ = v;
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.multi_party_ecdsa.gg18.sign.Round5BCMessage.V)
}

// .safeheron.proto.CurvePoint A = 2;
inline bool Round5BCMessage::_internal_has_a() const {
  return this != internal_default_instance() && a_ != nullptr;
}
inline bool Round5BCMessage::has_a() const {
  return _internal_has_a();
}
inline const ::safeheron::proto::CurvePoint& Round5BCMessage::_internal_a() const {
  const ::safeheron::proto::CurvePoint* p = a_;
  return p != nullptr ? *p : reinterpret_cast<const ::safeheron::proto::CurvePoint&>(
      ::safeheron::proto::_CurvePoint_default_instance_);
}
inline const ::safeheron::proto::CurvePoint& Round5BCMessage::a() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.multi_party_ecdsa.gg18.sign.Round5BCMessage.A)
  return _internal_a();
}
inline void Round5BCMessage::unsafe_arena_set_allocated_a(
    ::safeheron::proto::CurvePoint* a) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(a_);
  }
  a_ = a;
  if (a) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:safeheron.proto.multi_party_ecdsa.gg18.sign.Round5BCMessage.A)
}
inline ::safeheron::proto::CurvePoint* Round5BCMessage::release_a() {
  
  ::safeheron::proto::CurvePoint* temp = a_;
  a_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::safeheron::proto::CurvePoint* Round5BCMessage::unsafe_arena_release_a() {
  // @@protoc_insertion_point(field_release:safeheron.proto.multi_party_ecdsa.gg18.sign.Round5BCMessage.A)
  
  ::safeheron::proto::CurvePoint* temp = a_;
  a_ = nullptr;
  return temp;
}
inline ::safeheron::proto::CurvePoint* Round5BCMessage::_internal_mutable_a() {
  
  if (a_ == nullptr) {
    auto* p = CreateMaybeMessage<::safeheron::proto::CurvePoint>(GetArenaForAllocation());
    a_ = p;
  }
  return a_;
}
inline ::safeheron::proto::CurvePoint* Round5BCMessage::mutable_a() {
  ::safeheron::proto::CurvePoint* _msg = _internal_mutable_a();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.multi_party_ecdsa.gg18.sign.Round5BCMessage.A)
  return _msg;
}
inline void Round5BCMessage::set_allocated_a(::safeheron::proto::CurvePoint* a) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(a_);
  }
  if (a) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(a));
    if (message_arena != submessage_arena) {
      a = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, a, submessage_arena);
    }
    
  } else {
    
  }
  a_ = a;
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.multi_party_ecdsa.gg18.sign.Round5BCMessage.A)
}

// string blind_factor = 4;
inline void Round5BCMessage::clear_blind_factor() {
  blind_factor_.ClearToEmpty();
}
inline const std::string& Round5BCMessage::blind_factor() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.multi_party_ecdsa.gg18.sign.Round5BCMessage.blind_factor)
  return _internal_blind_factor();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Round5BCMessage::set_blind_factor(ArgT0&& arg0, ArgT... args) {
 
 blind_factor_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.multi_party_ecdsa.gg18.sign.Round5BCMessage.blind_factor)
}
inline std::string* Round5BCMessage::mutable_blind_factor() {
  std::string* _s = _internal_mutable_blind_factor();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.multi_party_ecdsa.gg18.sign.Round5BCMessage.blind_factor)
  return _s;
}
inline const std::string& Round5BCMessage::_internal_blind_factor() const {
  return blind_factor_.Get();
}
inline void Round5BCMessage::_internal_set_blind_factor(const std::string& value) {
  
  blind_factor_.Set(value, GetArenaForAllocation());
}
inline std::string* Round5BCMessage::_internal_mutable_blind_factor() {
  
  return blind_factor_.Mutable(GetArenaForAllocation());
}
inline std::string* Round5BCMessage::release_blind_factor() {
  // @@protoc_insertion_point(field_release:safeheron.proto.multi_party_ecdsa.gg18.sign.Round5BCMessage.blind_factor)
  return blind_factor_.Release();
}
inline void Round5BCMessage::set_allocated_blind_factor(std::string* blind_factor) {
  if (blind_factor != nullptr) {
    
  } else {
    
  }
  blind_factor_.SetAllocated(blind_factor, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (blind_factor_.IsDefault()) {
    blind_factor_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.multi_party_ecdsa.gg18.sign.Round5BCMessage.blind_factor)
}

// .safeheron.proto.LinearCombinationProof lc_proof_VRG = 5;
inline bool Round5BCMessage::_internal_has_lc_proof_vrg() const {
  return this != internal_default_instance() && lc_proof_vrg_ != nullptr;
}
inline bool Round5BCMessage::has_lc_proof_vrg() const {
  return _internal_has_lc_proof_vrg();
}
inline const ::safeheron::proto::LinearCombinationProof& Round5BCMessage::_internal_lc_proof_vrg() const {
  const ::safeheron::proto::LinearCombinationProof* p = lc_proof_vrg_;
  return p != nullptr ? *p : reinterpret_cast<const ::safeheron::proto::LinearCombinationProof&>(
      ::safeheron::proto::_LinearCombinationProof_default_instance_);
}
inline const ::safeheron::proto::LinearCombinationProof& Round5BCMessage::lc_proof_vrg() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.multi_party_ecdsa.gg18.sign.Round5BCMessage.lc_proof_VRG)
  return _internal_lc_proof_vrg();
}
inline void Round5BCMessage::unsafe_arena_set_allocated_lc_proof_vrg(
    ::safeheron::proto::LinearCombinationProof* lc_proof_vrg) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lc_proof_vrg_);
  }
  lc_proof_vrg_ = lc_proof_vrg;
  if (lc_proof_vrg) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:safeheron.proto.multi_party_ecdsa.gg18.sign.Round5BCMessage.lc_proof_VRG)
}
inline ::safeheron::proto::LinearCombinationProof* Round5BCMessage::release_lc_proof_vrg() {
  
  ::safeheron::proto::LinearCombinationProof* temp = lc_proof_vrg_;
  lc_proof_vrg_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::safeheron::proto::LinearCombinationProof* Round5BCMessage::unsafe_arena_release_lc_proof_vrg() {
  // @@protoc_insertion_point(field_release:safeheron.proto.multi_party_ecdsa.gg18.sign.Round5BCMessage.lc_proof_VRG)
  
  ::safeheron::proto::LinearCombinationProof* temp = lc_proof_vrg_;
  lc_proof_vrg_ = nullptr;
  return temp;
}
inline ::safeheron::proto::LinearCombinationProof* Round5BCMessage::_internal_mutable_lc_proof_vrg() {
  
  if (lc_proof_vrg_ == nullptr) {
    auto* p = CreateMaybeMessage<::safeheron::proto::LinearCombinationProof>(GetArenaForAllocation());
    lc_proof_vrg_ = p;
  }
  return lc_proof_vrg_;
}
inline ::safeheron::proto::LinearCombinationProof* Round5BCMessage::mutable_lc_proof_vrg() {
  ::safeheron::proto::LinearCombinationProof* _msg = _internal_mutable_lc_proof_vrg();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.multi_party_ecdsa.gg18.sign.Round5BCMessage.lc_proof_VRG)
  return _msg;
}
inline void Round5BCMessage::set_allocated_lc_proof_vrg(::safeheron::proto::LinearCombinationProof* lc_proof_vrg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(lc_proof_vrg_);
  }
  if (lc_proof_vrg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(lc_proof_vrg));
    if (message_arena != submessage_arena) {
      lc_proof_vrg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lc_proof_vrg, submessage_arena);
    }
    
  } else {
    
  }
  lc_proof_vrg_ = lc_proof_vrg;
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.multi_party_ecdsa.gg18.sign.Round5BCMessage.lc_proof_VRG)
}

// .safeheron.proto.DLogProof_V2 dlog_proof_rho = 6;
inline bool Round5BCMessage::_internal_has_dlog_proof_rho() const {
  return this != internal_default_instance() && dlog_proof_rho_ != nullptr;
}
inline bool Round5BCMessage::has_dlog_proof_rho() const {
  return _internal_has_dlog_proof_rho();
}
inline const ::safeheron::proto::DLogProof_V2& Round5BCMessage::_internal_dlog_proof_rho() const {
  const ::safeheron::proto::DLogProof_V2* p = dlog_proof_rho_;
  return p != nullptr ? *p : reinterpret_cast<const ::safeheron::proto::DLogProof_V2&>(
      ::safeheron::proto::_DLogProof_V2_default_instance_);
}
inline const ::safeheron::proto::DLogProof_V2& Round5BCMessage::dlog_proof_rho() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.multi_party_ecdsa.gg18.sign.Round5BCMessage.dlog_proof_rho)
  return _internal_dlog_proof_rho();
}
inline void Round5BCMessage::unsafe_arena_set_allocated_dlog_proof_rho(
    ::safeheron::proto::DLogProof_V2* dlog_proof_rho) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dlog_proof_rho_);
  }
  dlog_proof_rho_ = dlog_proof_rho;
  if (dlog_proof_rho) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:safeheron.proto.multi_party_ecdsa.gg18.sign.Round5BCMessage.dlog_proof_rho)
}
inline ::safeheron::proto::DLogProof_V2* Round5BCMessage::release_dlog_proof_rho() {
  
  ::safeheron::proto::DLogProof_V2* temp = dlog_proof_rho_;
  dlog_proof_rho_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::safeheron::proto::DLogProof_V2* Round5BCMessage::unsafe_arena_release_dlog_proof_rho() {
  // @@protoc_insertion_point(field_release:safeheron.proto.multi_party_ecdsa.gg18.sign.Round5BCMessage.dlog_proof_rho)
  
  ::safeheron::proto::DLogProof_V2* temp = dlog_proof_rho_;
  dlog_proof_rho_ = nullptr;
  return temp;
}
inline ::safeheron::proto::DLogProof_V2* Round5BCMessage::_internal_mutable_dlog_proof_rho() {
  
  if (dlog_proof_rho_ == nullptr) {
    auto* p = CreateMaybeMessage<::safeheron::proto::DLogProof_V2>(GetArenaForAllocation());
    dlog_proof_rho_ = p;
  }
  return dlog_proof_rho_;
}
inline ::safeheron::proto::DLogProof_V2* Round5BCMessage::mutable_dlog_proof_rho() {
  ::safeheron::proto::DLogProof_V2* _msg = _internal_mutable_dlog_proof_rho();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.multi_party_ecdsa.gg18.sign.Round5BCMessage.dlog_proof_rho)
  return _msg;
}
inline void Round5BCMessage::set_allocated_dlog_proof_rho(::safeheron::proto::DLogProof_V2* dlog_proof_rho) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(dlog_proof_rho_);
  }
  if (dlog_proof_rho) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(dlog_proof_rho));
    if (message_arena != submessage_arena) {
      dlog_proof_rho = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dlog_proof_rho, submessage_arena);
    }
    
  } else {
    
  }
  dlog_proof_rho_ = dlog_proof_rho;
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.multi_party_ecdsa.gg18.sign.Round5BCMessage.dlog_proof_rho)
}

// -------------------------------------------------------------------

// Round6BCMessage

// string commitment = 1;
inline void Round6BCMessage::clear_commitment() {
  commitment_.ClearToEmpty();
}
inline const std::string& Round6BCMessage::commitment() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.multi_party_ecdsa.gg18.sign.Round6BCMessage.commitment)
  return _internal_commitment();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Round6BCMessage::set_commitment(ArgT0&& arg0, ArgT... args) {
 
 commitment_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.multi_party_ecdsa.gg18.sign.Round6BCMessage.commitment)
}
inline std::string* Round6BCMessage::mutable_commitment() {
  std::string* _s = _internal_mutable_commitment();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.multi_party_ecdsa.gg18.sign.Round6BCMessage.commitment)
  return _s;
}
inline const std::string& Round6BCMessage::_internal_commitment() const {
  return commitment_.Get();
}
inline void Round6BCMessage::_internal_set_commitment(const std::string& value) {
  
  commitment_.Set(value, GetArenaForAllocation());
}
inline std::string* Round6BCMessage::_internal_mutable_commitment() {
  
  return commitment_.Mutable(GetArenaForAllocation());
}
inline std::string* Round6BCMessage::release_commitment() {
  // @@protoc_insertion_point(field_release:safeheron.proto.multi_party_ecdsa.gg18.sign.Round6BCMessage.commitment)
  return commitment_.Release();
}
inline void Round6BCMessage::set_allocated_commitment(std::string* commitment) {
  if (commitment != nullptr) {
    
  } else {
    
  }
  commitment_.SetAllocated(commitment, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (commitment_.IsDefault()) {
    commitment_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.multi_party_ecdsa.gg18.sign.Round6BCMessage.commitment)
}

// -------------------------------------------------------------------

// Round7BCMessage

// .safeheron.proto.CurvePoint U = 1;
inline bool Round7BCMessage::_internal_has_u() const {
  return this != internal_default_instance() && u_ != nullptr;
}
inline bool Round7BCMessage::has_u() const {
  return _internal_has_u();
}
inline const ::safeheron::proto::CurvePoint& Round7BCMessage::_internal_u() const {
  const ::safeheron::proto::CurvePoint* p = u_;
  return p != nullptr ? *p : reinterpret_cast<const ::safeheron::proto::CurvePoint&>(
      ::safeheron::proto::_CurvePoint_default_instance_);
}
inline const ::safeheron::proto::CurvePoint& Round7BCMessage::u() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.multi_party_ecdsa.gg18.sign.Round7BCMessage.U)
  return _internal_u();
}
inline void Round7BCMessage::unsafe_arena_set_allocated_u(
    ::safeheron::proto::CurvePoint* u) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(u_);
  }
  u_ = u;
  if (u) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:safeheron.proto.multi_party_ecdsa.gg18.sign.Round7BCMessage.U)
}
inline ::safeheron::proto::CurvePoint* Round7BCMessage::release_u() {
  
  ::safeheron::proto::CurvePoint* temp = u_;
  u_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::safeheron::proto::CurvePoint* Round7BCMessage::unsafe_arena_release_u() {
  // @@protoc_insertion_point(field_release:safeheron.proto.multi_party_ecdsa.gg18.sign.Round7BCMessage.U)
  
  ::safeheron::proto::CurvePoint* temp = u_;
  u_ = nullptr;
  return temp;
}
inline ::safeheron::proto::CurvePoint* Round7BCMessage::_internal_mutable_u() {
  
  if (u_ == nullptr) {
    auto* p = CreateMaybeMessage<::safeheron::proto::CurvePoint>(GetArenaForAllocation());
    u_ = p;
  }
  return u_;
}
inline ::safeheron::proto::CurvePoint* Round7BCMessage::mutable_u() {
  ::safeheron::proto::CurvePoint* _msg = _internal_mutable_u();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.multi_party_ecdsa.gg18.sign.Round7BCMessage.U)
  return _msg;
}
inline void Round7BCMessage::set_allocated_u(::safeheron::proto::CurvePoint* u) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(u_);
  }
  if (u) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(u));
    if (message_arena != submessage_arena) {
      u = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, u, submessage_arena);
    }
    
  } else {
    
  }
  u_ = u;
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.multi_party_ecdsa.gg18.sign.Round7BCMessage.U)
}

// .safeheron.proto.CurvePoint T = 2;
inline bool Round7BCMessage::_internal_has_t() const {
  return this != internal_default_instance() && t_ != nullptr;
}
inline bool Round7BCMessage::has_t() const {
  return _internal_has_t();
}
inline const ::safeheron::proto::CurvePoint& Round7BCMessage::_internal_t() const {
  const ::safeheron::proto::CurvePoint* p = t_;
  return p != nullptr ? *p : reinterpret_cast<const ::safeheron::proto::CurvePoint&>(
      ::safeheron::proto::_CurvePoint_default_instance_);
}
inline const ::safeheron::proto::CurvePoint& Round7BCMessage::t() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.multi_party_ecdsa.gg18.sign.Round7BCMessage.T)
  return _internal_t();
}
inline void Round7BCMessage::unsafe_arena_set_allocated_t(
    ::safeheron::proto::CurvePoint* t) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(t_);
  }
  t_ = t;
  if (t) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:safeheron.proto.multi_party_ecdsa.gg18.sign.Round7BCMessage.T)
}
inline ::safeheron::proto::CurvePoint* Round7BCMessage::release_t() {
  
  ::safeheron::proto::CurvePoint* temp = t_;
  t_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::safeheron::proto::CurvePoint* Round7BCMessage::unsafe_arena_release_t() {
  // @@protoc_insertion_point(field_release:safeheron.proto.multi_party_ecdsa.gg18.sign.Round7BCMessage.T)
  
  ::safeheron::proto::CurvePoint* temp = t_;
  t_ = nullptr;
  return temp;
}
inline ::safeheron::proto::CurvePoint* Round7BCMessage::_internal_mutable_t() {
  
  if (t_ == nullptr) {
    auto* p = CreateMaybeMessage<::safeheron::proto::CurvePoint>(GetArenaForAllocation());
    t_ = p;
  }
  return t_;
}
inline ::safeheron::proto::CurvePoint* Round7BCMessage::mutable_t() {
  ::safeheron::proto::CurvePoint* _msg = _internal_mutable_t();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.multi_party_ecdsa.gg18.sign.Round7BCMessage.T)
  return _msg;
}
inline void Round7BCMessage::set_allocated_t(::safeheron::proto::CurvePoint* t) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(t_);
  }
  if (t) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(t));
    if (message_arena != submessage_arena) {
      t = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, t, submessage_arena);
    }
    
  } else {
    
  }
  t_ = t;
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.multi_party_ecdsa.gg18.sign.Round7BCMessage.T)
}

// string blind_factor = 3;
inline void Round7BCMessage::clear_blind_factor() {
  blind_factor_.ClearToEmpty();
}
inline const std::string& Round7BCMessage::blind_factor() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.multi_party_ecdsa.gg18.sign.Round7BCMessage.blind_factor)
  return _internal_blind_factor();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Round7BCMessage::set_blind_factor(ArgT0&& arg0, ArgT... args) {
 
 blind_factor_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.multi_party_ecdsa.gg18.sign.Round7BCMessage.blind_factor)
}
inline std::string* Round7BCMessage::mutable_blind_factor() {
  std::string* _s = _internal_mutable_blind_factor();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.multi_party_ecdsa.gg18.sign.Round7BCMessage.blind_factor)
  return _s;
}
inline const std::string& Round7BCMessage::_internal_blind_factor() const {
  return blind_factor_.Get();
}
inline void Round7BCMessage::_internal_set_blind_factor(const std::string& value) {
  
  blind_factor_.Set(value, GetArenaForAllocation());
}
inline std::string* Round7BCMessage::_internal_mutable_blind_factor() {
  
  return blind_factor_.Mutable(GetArenaForAllocation());
}
inline std::string* Round7BCMessage::release_blind_factor() {
  // @@protoc_insertion_point(field_release:safeheron.proto.multi_party_ecdsa.gg18.sign.Round7BCMessage.blind_factor)
  return blind_factor_.Release();
}
inline void Round7BCMessage::set_allocated_blind_factor(std::string* blind_factor) {
  if (blind_factor != nullptr) {
    
  } else {
    
  }
  blind_factor_.SetAllocated(blind_factor, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (blind_factor_.IsDefault()) {
    blind_factor_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.multi_party_ecdsa.gg18.sign.Round7BCMessage.blind_factor)
}

// -------------------------------------------------------------------

// Round8BCMessage

// string si = 1;
inline void Round8BCMessage::clear_si() {
  si_.ClearToEmpty();
}
inline const std::string& Round8BCMessage::si() const {
  // @@protoc_insertion_point(field_get:safeheron.proto.multi_party_ecdsa.gg18.sign.Round8BCMessage.si)
  return _internal_si();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Round8BCMessage::set_si(ArgT0&& arg0, ArgT... args) {
 
 si_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:safeheron.proto.multi_party_ecdsa.gg18.sign.Round8BCMessage.si)
}
inline std::string* Round8BCMessage::mutable_si() {
  std::string* _s = _internal_mutable_si();
  // @@protoc_insertion_point(field_mutable:safeheron.proto.multi_party_ecdsa.gg18.sign.Round8BCMessage.si)
  return _s;
}
inline const std::string& Round8BCMessage::_internal_si() const {
  return si_.Get();
}
inline void Round8BCMessage::_internal_set_si(const std::string& value) {
  
  si_.Set(value, GetArenaForAllocation());
}
inline std::string* Round8BCMessage::_internal_mutable_si() {
  
  return si_.Mutable(GetArenaForAllocation());
}
inline std::string* Round8BCMessage::release_si() {
  // @@protoc_insertion_point(field_release:safeheron.proto.multi_party_ecdsa.gg18.sign.Round8BCMessage.si)
  return si_.Release();
}
inline void Round8BCMessage::set_allocated_si(std::string* si) {
  if (si != nullptr) {
    
  } else {
    
  }
  si_.SetAllocated(si, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (si_.IsDefault()) {
    si_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:safeheron.proto.multi_party_ecdsa.gg18.sign.Round8BCMessage.si)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace sign
}  // namespace gg18
}  // namespace multi_party_ecdsa
}  // namespace proto
}  // namespace safeheron

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_gg18_2fsign_2eproto
